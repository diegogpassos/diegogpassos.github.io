<!DOCTYPE html>
<html>
<head>

    <!-- Meta info -->
		<meta charset="utf-8">
		<meta name="shortauthor" content="Diego Passos"/>
		<meta name="shorttitle" content="P2P, DNS, Sockets, Transporte"/>
		<meta name="shortevent" content="Redes de Computadores"/>
		<title>Redes de Computadores: Aula 3</title>

		<!-- Math support -->
		<script type="text/x-mathjax-config">
		MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
			MathJax.InputJax.TeX.Definitions.number = /^(?:[0-9]+(?:\.[0-9]{3})*(?:\{,\}[0-9]*)*|\{,\}[0-9]+)/
		});
		</script>
		<script src="js/plotly-latest.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
		<script src="../../../../../MathJax-2.6-latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
		<script type="text/javascript" src="../template/js/dz_pre.js"></script>

		<!-- Fonts -->
		<link href='https://fonts.googleapis.com/css?family=Lora:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
		<link href='../../../../../Fonts/Lora/lora.css' rel='stylesheet' type='text/css'>

		<!-- CSS -->
		<link href='../template/css/template.css' id="template" rel='stylesheet' type='text/css'>
		<link href='../template/css/presentationSpecific.css' id="presentationSpecific" rel='stylesheet' type='text/css'>


		<!-- Javascript -->
		<script type="text/javascript" src="../template/js/audio.js"></script>
		<script src="js/term.js" charset="utf-8"></script>
        <script src="js/termcast.js" charset="utf-8"></script>
		<link rel="stylesheet" href="css/googlecode.css">
		<script src="js/highlight.pack.js"></script>
		<script>
			hljs.initHighlightingOnLoad();
			hljs.configure({
				tabReplace: '  '
			});
		</script>
</head>

<body>
    <!-- Audio handlers -->
	<!--<audio src="audio/La.wav" id="La.wav" preload="auto"></audio>-->

    <!-- Title Slide -->
	<section>

        <div class="slideContent">
            <h1 class="title">Aula 3 - P2P, DNS, Sockets, Camada de Transporte, UDP</h1>
            <h2 class="author">Diego Passos</h2>
            <h4 class="institution">Universidade Federal Fluminense</h4>
            <h3 class="date">Redes de Computadores</h3>
        </div>

	<br>
	<div style="width: 30%; float: right; padding-right: 2%;">
	<p style="font-size: 18px; text-align: right;">Material adaptado a partir dos slides originais de J.F Kurose and K.W. Ross.</p>
	</div>
	</section>

    <section class="secao">
    <div class="slideContent">
        Aplicações P2P
    </div>
    </section>

    <section>
    <h1>Arquitetura P2P Pura</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <br>
            <br>
            <ul>
                <li>Não há servidor sempre ligado.</li>
                <li>Sistemas finais arbitrários se comunicam diretamente.</li>
                <li>Pares se conectam à rede P2P de forma intermitente, podem trocar de endereço IP.</li>
                <li><b>Exemplos:</b>
                <ul>
                    <li>Distribuição de arquivos (<i>e.g.</i>, BitTorrent).</li>
                    <li><i>Streaming</i> (<i>e.g.</i>, KanKan).</li>
                    <li>VoIP (<i>e.g.</i>, Skype).</li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
                <object type="image/svg+xml" data="imagens/P2PArquitetura.svg" style="width: 70%;"></object>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>Distribuição de Arquivos: Cliente&mdash;Servidor <i>vs.</i> P2P</h1>
    <div class="slideContent">
        <ul>
            <li><span class="alert">Pergunta:</span> quanto tempo é necessário para distribuir um arquivo (tamanho F) de um servidor para N clientes?
            <ul>
                <li>Capacidades de <i>download/upload</i> dos clientes é um recurso limitado.</li>
            </ul></li>
        </ul>
        <br>
        <center>
            <object type="image/svg+xml" data="imagens/P2PvsClienteServidor.svg" style="width: 80%;"></object>
        </center>
    </div>
    </section>

    <section>
    <h1>Distribuição de Arquivos: Cliente&mdash;Servidor</h1>
    <div class="slideContent">
        <div style="height: 225px;">
            <div class="column" style="width: 60%;">
                <ul>
                    <li><b>Transmissão pelo servidor:</b> precisa enviar (<i>upload</i>) <span class="alert">sequencialmente</span> N cópias do arquivo.
                    <ul>
                        <li>Tempo para enviar uma cópia: <span class="math inline">\(\frac{F}{u_s}\)</span>.</li>
                        <li>Tempo para enviar N cópias: <span class="math inline">\(\frac{N\cdot F}{u_s}\)</span>.</li>
                    </ul></li>
                </ul>
            </div>
            <div class="column" style="width: 40%;">
                <center>
                    <object type="image/svg+xml" data="imagens/P2PvsClienteServidor.svg" style="width: 95%;"></object>
                </center>
            </div>
        </div>
        <div>
            <ul>
                <li><b>Cliente:</b> cada cliente precisa receber (<i>download</i>) sua cópia do arquivo.
                    <ul>
                        <li><span class="math inline">\(d_{min} = \)</span> capacidade de <i>download</i> mínima entre todos os clientes.</li>
                        <li>Tempo máximo de <i>download</i> entre os clientes: <span class="math inline">\(\frac{F}{d_{min}}\)</span>.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <center>
        <div style="width: 80%; padding: 5px; border: 2px solid #4a4; height: 160px;">
            <div class="column" style="width: 50%;">
                <br>
                Tempo para distribuir arquivo de tamanho F para N clientes utilizando abordagem Cliente&mdash;Servidor
            </div>
            <div class="column" style="width: 50%;">
                <br>
                <center>
                    <span class="math inline">\(D_{C-S} = max\left\{\frac{N\cdot F}{u{s}}, \frac{F}{d_{min}}\right\}\)</span>
                </center>
            </div>
        </div>
        </center>
    </div>
    </section>

    <section>
    <h1>Distribuição de Arquivos: P2P</h1>
    <div class="slideContent">
        <div style="height: 300px;">
            <div class="column" style="width: 60%;">
                <ul>
                    <li><b>Transmissão pelo servidor:</b> precisa enviar (<i>upload</i>) <span class="alert">ao menos uma cópia</span>.
                    <ul>
                        <li>Tempo para enviar uma cópia: <span class="math inline">\(\frac{F}{u_s}\)</span>.</li>
                    </ul></li>
                    <li><b>Cliente:</b> cada cliente precisa receber (<i>download</i>) sua cópia do arquivo.
                    <ul>
                        <li>Tempo máximo de <i>download</i> entre os clientes: <span class="math inline">\(\frac{F}{d_{min}}\)</span>.</li>
                    </ul></li>
                </ul>
            </div>
            <div class="column" style="width: 40%;">
                <center>
                    <object type="image/svg+xml" data="imagens/P2PvsClienteServidor.svg" style="width: 90%;"></object>
                </center>
            </div>
        </div>
        <br>
        <ul>
            <li><b>Clientes:</b> em conjunto, clientes farão <i>download</i> de <span class="math inline">\(N\cdot F\)</span> bits.
            <ul>
                <li>Taxa máxima de <i>upload</i> (que limita taxa de <i>download</i>) é <span class="math inline">\(u_{s} + \sum{u_i}\)</span>.</li>
            </ul></li>
        </ul>

        <center>
        <div style="width: 80%; padding: 5px; border: 2px solid #4a4; height: 150px;">
            <div class="column" style="width: 50%;">
                <br>
                Tempo para distribuir arquivo de tamanho F para N clientes utilizando abordagem P2P
            </div>
            <div class="column" style="width: 50%;">
                <br>
                <center>
                    <span class="math inline">\(D_{P2P} = max\left\{\frac{F}{u{s}}, \frac{F}{d_{min}}, \frac{N\cdot F}{u_{s} + \sum{u_i}}\right\}\)</span>
                </center>
            </div>
        </div>
        </center>
    </div>
    </section>

    <section>
    <h1>Distribuição de Arquivos: Comparação (I)</h1>
    <div class="slideContent">
        <ul>
            <li>Caso Cliente&mdash;Servidor:
            <ul>
                <center>
                    <span class="math inline">\(D_{C-S} = max\left\{\frac{N\cdot F}{u{s}}, \frac{F}{d_{min}}\right\}\)</span>
                </center>
                <li>Demanda cresce linearmente com N.</li>
                <li>Capacidade do servidor é fixa.</li>
            </ul></li>
            <li>Caso P2P:
            <ul>
                <center>
                    <span class="math inline">\(D_{P2P} = max\left\{\frac{F}{u{s}}, \frac{F}{d_{min}}, \frac{N\cdot F}{u_{s} + \sum{u_i}}\right\}\)</span>
                </center>
                <li>Demanda aumenta linearmente com N.</li>
                <li>Mas também a capacidade de <i>upload</i>.</li>
                <li>Resultado: <span class="alert">tempo de distribuição cresce, mas de forma mais escalável.</span></li>
            </ul></li>
        </ul>
    </div>
    </section>

    <section>
    <h1>Distribuição de Arquivos: Comparação (II)</h1>
    <div class="slideContent">
        <ul>
            <li>Exemplo numérico:
            <ul>
                <li><span class="math inline">\(\frac{F}{u} = 1\)</span> hora.</li>
                <li>Capacidade de <i>upload</i> do servidor 10x maior que dos clientes.</li>
                <li><span class="math inline">\(d_{min} \ge u{s}\)</span>.</li>
            </ul></li>
        </ul>
        <center>
            <object type="image/svg+xml" data="imagens/P2PGrafico.svg" style="width: 50%;"></object>
        </center>
    </div>
    </section>

    <section>
    <h1>Distribuição de Arquivos P2P: Exemplo do BitTorrent (I)</h1>
    <div class="slideContent">
        <ul>
            <li>Arquivo dividio em pedaços de (normalmente) 256KB.</li>
            <li>Pares no torrent enviam/recebem pedaços do arquivo.</li>
        </ul>

        <center>
            <object type="image/svg+xml" data="imagens/BitTorrent.svg" style="width: 75%;"></object>
        </center>
    </div>
    </section>

    <section>
    <h1>Distribuição de Arquivos P2P: Exemplo do BitTorrent (II)</h1>
    <div class="slideContent">
        <div style="height: 270px;">
            <div class="column" style="width: 50%;">
                <ul>
                    <li>Par se junta ao torrent:
                    <ul>
                        <li>Não possui nenhum pedaço, mas os acumulará com o tempo de outros pares.</li>
                        <li>Se registra com o <i>tracker</i> para obter uma lista de pares, se conecta a um subconjunto dos pares (&ldquo;vizinhos&rdquo;).</li>
                    </ul></li>
                </ul>
            </div>
            <div class="column" style="width: 50%;">
                <center>
                    <object type="image/svg+xml" data="imagens/BitTorrentSimplificado.svg" style="width: 70%;"></object>
                </center>
            </div>
        </div>
        <ul>
            <li>Enquanto baixa, pares fazem <i>upload</i> para outros pares.</li>
            <li>Par pode alterar os pares com que troca pedaços.</li>
            <li><span class="alert">Churn:</span> pares vem e vão.</li>
            <li>Quando um par tem o arquivo inteiro (todos os pedaços), ele pode (de forma egoísta) sair ou (de forma autruísta) ficar no torrent.</li>
        </ul>
    </div>
    </section>

    <section>
    <h1>BitTorrent: Requisitando, Enviando Pedaços do Arquivo</h1>
    <div class="slideContent">
        <div class="column" style="width: 45%;">
            <ul>
                <li><b>Requisitando pedaços</b>:
                <ul>
                    <li>Em um dado momento, diferentes pares possuem diferentes subconjuntos dos pedaços do arquivo.</li>
                    <li>Periodicamente, um par pede aos outros pares uma lista dos pedaços que possuem.</li>
                    <li>Par então requisita pedaços que não possui aos pares, começando pelos mais raros.</li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 55%;">
            <ul>
                <li><b>Enviando pedaços: <i>tit-for-tat</i></b>.
                <ul>
                    <li>Par envia pedaços aos 4 pares que atualmente o enviam pedaços na taxa mais alta.
                    <ul>
                        <li>Outros pares sofrem <i>choking</i> (<i>i.e.</i>, não recebem pedaços).</li>
                        <li>Uma nova avaliação dos 4 melhores pares é feita a cada 10 segundos.</li>
                    </ul></li>
                    <li>A cada 30 segundos: par seleciona aleatoriamente outro par, começa a enviar pedaços.
                    <ul>
                        <li><i>Optimistically unchoke</i>.</li>
                        <li>Dá oportunidade de pares demonstrarem que são bons <i>uploaders</i>.</li>
                        <li>Par escolhido de forma aleatória pode se tornar um dos 4 melhores.</li>
                    </ul></li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <section>
    <h1>BitTorrent: Tit-For-Tat</h1>
    <div class="slideContent">
        <center>
            <object type="image/svg+xml" data="imagens/BitTorrentTitForTat.svg" style="width: 70%;"></object>
        </center>
    </div>
    </section>

	<section class="secao">
    <div class="slideContent">
        DNS
    </div>
    </section>

    <section>
    <h1>DNS: <i>Domain Name System</i></h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <ul>
                <li><b>Pessoas:</b> muitos identificadores.
                <ul>
                    <li>CPF, RG, # de passaporte, ...</li>
                </ul></li>
                <li><b>Hosts e roteadores na Internet:</b>
                <ul>
                    <li>Endereço IP (# de 32 bits) usado para endereçar datagramas.</li>
                    <li>&ldquo;Nome&rdquo;, <i>e.g.</i>, <tt>www.yahoo.com</tt>, usado por humanos.</li>
                </ul></li>
                <li><span class="alert">Pergunta:</span> como mapear nomes para seus respectivos IPs e vice-versa?</li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li><b>Domain Name System (DNS):</b>
                <ul>
                    <li><span class="alert">Base de dados distribuída:</span> implementada em uma hierarquia de múltiplos <span class="alert">servidores de nomes</span>.</li>
                    <li><span class="alert">Protocolo da camada de aplicação:</span> <i>hosts</i> e servidores de nome se comunicam para <span class="alert">resolver</span> nomes (tradução entre nome e endereço IP).
                    <ul>
                        <li>Note: função fundamental da Internet implementada como protocolo de aplicação.</li>
                        <li>Complexidade nas bordas.</li>
                    </ul></li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <section>
    <h1>DNS: Serviços, Estrutura</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <ul>
                <li><b>Serviços do DNS</b>:
                <ul>
                    <li>Tradução de nomes de <i>hosts</i> para endereços IP.</li>
                    <li><i>Host aliasing</i>.
                    <ul>
                        <li>Atribuição de &ldquo;apelidos&rdquo;.</li>
                        <li><i>Host</i> possui <span class="alert">nome canônico</span> e, possivelmente, vários apelidos.</li>
                    </ul></li>
                    <li><i>Aliasing</i> de servidores de e-mail.</li>
                    <li>Balanceamento de carga.
                    <ul>
                        <li>Servidores web replicados.</li>
                        <li>Cada servidor com seu IP.</li>
                        <li>Mas o mesmo nome associado a vários IPs.</li>
                    </ul></li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li><b>Por que não um DNS centralizado?</b>
                <ul>
                    <li>Ponto único de falha.</li>
                    <li>Concentração de grande volume de tráfego.</li>
                    <li>Base de dados centralizada distante.</li>
                    <li>Manutenção.</li>
                </ul></li>
            </ul>
            <br>
            <center>
                Em suma: <span class="alert">não escala!</span>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>DNS: Balanceamento de Carga</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <div id="termcastDNSBalanceamento" style="margin-left: 3px;"></div>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li>Aplicação (ping) requisita resolução de nome <tt>www.google.com</tt>:
                <ul>
                    <li>Primeiras execuções associam nome a <tt>216.58.222.100</tt>.</li>
                    <li>Eventualmente, respostas diferentes: <tt>216.58.222.68</tt>.</li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <script type="text/javascript">
            var TermCast1;
            DzAddPostInitFunction(function() {

                    TermCast1 = new TermCast(document.getElementById('termcastDNSBalanceamento'), 'terminalSessions/BalanceamentoDeCarga.json');
            });
        </script>

    <section>
    <h1>Alias (Apelidos)</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <div id="termcastAlias" style="margin-left: 3px;"></div>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li>Primeira resolução para o nome <tt>www.midiacom.uff.br</tt>:
                <ul>
                    <li>Nome associado ao IP <tt>200.20.10.93</tt>.</li>
                </ul></li>
                <li>Segunda resolução para <tt>mesbla.midiacom.uff.br</tt>:
                <ul>
                    <li>Associado ao mesmo IP!.</li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <script type="text/javascript">
            var TermCast2;
            DzAddPostInitFunction(function() {

                    TermCast2 = new TermCast(document.getElementById('termcastAlias'), 'terminalSessions/alias.json');
            });
        </script>

    <section>
    <h1>DNS: Uma Base de Dados Hierárquica e Distribuída</h1>
    <div class="slideContent">
        <center>
            <object type="image/svg+xml" data="imagens/DNSHierarquico.svg" style="width: 70%;"></object>
        </center>
        <br>
        <ul>
            <li><b>Cliente quer IP de <tt>www.amazon.com</tt>. Primeira abordagem:</b>
            <ul>
                <li>Cliente pergunta ao servidor raiz a localização do DNS do <span class="alert">domínio</span> <tt>.com</tt>.</li>
                <li>Cliente pergunta ao servidor DNS do domínio <tt>.com</tt> a localização do servidor DNS do domínio <tt>amazon.com</tt>.</li>
                <li>Cliente pergunta ao servidor DNS do domínio <tt>amazon.com</tt> pelo endereço IP do <i>host</i> <tt>www.amazon.com</tt>.</li>
            </ul></li>
        </ul>
    </div>
    </section>

    <section>
    <h1>DNS: Servidores Raiz</h1>
    <div class="slideContent">
        <ul>
            <li>Conhecem os servidores TLD.</li>
            <li>Contactados (principalmente) quando se deseja saber o DNS de um TLD.</li>
            <li>Poucos &ldquo;servidores&rdquo; no mundo.
            <ul>
                <li>Embora cada um seja composto por vários computadores espalhados pelo mundo.</li>
            </ul></li>
        </ul>
        <br>
        <center>
            <object type="image/svg+xml" data="imagens/DNSRaiz.svg" style="width: 70%;"></object>
        </center>
    </div>
    </section>

    <section>
    <h1>TLD, Servidores Autoritativos</h1>
    <div class="slideContent">
        <ul>
            <li><b>Servidores <i>Top-Level Domain</i> (TLD):</b>
            <ul>
                <li>TLD: <tt>.org, .net, .com, .edu</tt>, ..., <tt>.br, .uk, .jp</tt>, ...</li>
                <li>Cada TLD tem seu servidor DNS específico.</li>
                <li>A Network Solutions mantém servidores DNS para o TLD <tt>.com</tt>.</li>
                <li>A Registro.br mantém o DNS para o TLD <tt>.br</tt>.</li>
            </ul></li>
            <li><b>Servidores autoritativos:</b>
            <ul>
                <li>Servidor de DNS de uma organização específica.</li>
                <li>Provê mapeamentos para os endereços IP da organização e seus nomes de <i>host</i>.</li>
                <li>Pode ser gerenciado pela própria organização ou por um provedor de serviço.</li>
            </ul></li>
        </ul>
    </div>
    </section>

    <section>
    <h1>TLDs</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <div id="termcastTLD" style="margin-left: 3px;"></div>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li>Primeira resolução para o nome <tt>www.google.com</tt>:
                <ul>
                    <li>Como esperado, bem sucedido.</li>
                    <li>TLD <tt>.com</tt></li>
                </ul></li>
                <li>Segunda resolução para <tt>com.google</tt>:
                <ul>
                    <li>Nome parece invertido: primeiro TLD, depois nome da organização.</li>
                    <li>Mas resolução é bem sucedida de qualquer forma!</li>
                    <li>Por que?
                    <ul>
                    <li>Atualmente, <tt>.google</tt> é um TLD.</li>
                    <li>Dentro deste TLD, há um <i>hostname</i> chamado <tt>com</tt>.</li>
                    </ul></li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <script type="text/javascript">
            var TermCast3;
            DzAddPostInitFunction(function() {

                    TermCast3 = new TermCast(document.getElementById('termcastTLD'), 'terminalSessions/tld.json');
            });
        </script>

    <section>
    <h1>Servidores DNS Locais</h1>
    <div class="slideContent">
        <ul>
            <li>Estritamente falando, não fazem parte da hierarquia.</li>
            <li>Cada ISP (residencial, empresas, universidades) normalmente tem um.
            <ul>
                <li>Também chamado de &ldquo;DNS padrão&rdquo;.</li>
            </ul></li>
            <li>Quando o <i>host</i> faz uma requisição DNS, esta é enviada para o seu servidor DNS local.
            <ul>
                <li>Geralmente, possui um cache para mapeamentos realizados recentemente (mas o mapeamento pode não ser mais válido!).</li>
                <li>Atua como um <i>proxy</i>, encaminhando requisições para a hierarquia.</li>
            </ul></li>
        </ul>
    </div>
    </section>

    <section>
    <h1>Exemplo de Resolução de Nome Usando DNS (I)</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <br>
            <br>
            <br>
            <br>
            <ul>
                <li><i>Host</i> em <tt>cis.poly.edu</tt> quer o IP de <tt>gaia.cs.umass.edu</tt>.</li>
                <li><b>Método iterativo:</b>
                <ul>
                    <li>Servidor contactado retorna nome de outro servidor a ser contactado.</li>
                    <li>&ldquo;Eu não conheço este nome, mas pergunte para este outro servidor&rdquo;.</li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
                <object type="image/svg+xml" data="imagens/DNSIterativo.svg" style="width: 80%;"></object>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>Exemplo de Resolução de Nome Usando DNS (II)</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <br>
            <br>
            <br>
            <ul>
                <li><b>Modo recursivo:</b>
                <ul>
                    <li>Coloca o fardo da resolução do nome no servidor contactado.</li>
                    <li>Alta carga nos níveis mais altos da hierarquia?</li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
                <object type="image/svg+xml" data="imagens/DNSRecursivo.svg" style="width: 80%;"></object>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>DNS: Cache, Atualização de Registros</h1>
    <div class="slideContent">
        <ul>
            <li>Uma vez aprendido um mapeamento, um servidor de nomes (qualquer) <span class="alert">o armazena em cache.</span>
            <ul>
                <li>Entradas na cache têm uma data de expiração (TTL).
                <ul>
                    <li><i>i.e.</i>, são jogadas fora depois de algum tempo.</li>
                </ul></li>
                <li>Servidores TLD tipicamente presentes na cache.
                <ul>
                    <li>Logo, servidores raiz raramente visitados.</li>
                </ul></li>
            </ul></li>
            <li>Entradas na cache podem ficar <span class="alert">desatualizadas</span>.
            <ul>
                <li>Serviço de tradução de melhor esforço!</li>
                <li>Se <i>host</i> tem IP alterado, restante da Internet pode não ficar sabendo até que TTLs expirem.</li>
            </ul></li>
            <li>Há propostas para mecanismos de atualização/notificação.
            <ul>
                <li><i>e.g.</i>, RFC 2136.</li>
            </ul></li>
        </ul>
    </div>
    </section>

    <section>
    <h1>Registros de DNS</h1>
    <div class="slideContent">
        <ul>
            <li><b>DNS:</b> base de dados distribuída que armazena <i>Resource Records</i> <span class="alert">(RR)</span>.</li>
        </ul>
        <br>
        <center>
            <div style="width: 50%; border: 2px solid #3a3; padding: 5px;">
                Formato de um RR: (nome, valor, tipo, TTL)
            </div>
        </center>
        <br>
        <div>
            <div class="column" style="width: 50%;">
                <ul>
                    <li><b>Tipo=A</b>
                    <ul>
                        <li><b>nome</b> é um nome de um <i>host</i>.</li>
                        <li><b>valor</b> é o endereço IP.</li>
                    </ul></li>
                    <li><b>Tipo=NS</b>
                    <ul>
                        <li><b>nome</b> é um domínio (<i>e.g.</i>, <tt>foo.com</tt>).</li>
                        <li><b>valor</b> é o <span class="alert">nome do host</span> do servidor DNS autoritativo para este domínio.</li>
                    </ul></li>
                </ul>
            </div>
            <div class="column" style="width: 50%;">
                <ul>
                    <li><b>Tipo=CNAME</b>
                    <ul>
                        <li><b>nome</b> é um apelido para um <i>host</i>.</li>
                        <li><b>value</b> é o <span class="alert">nome canônico</span>.</li>
                        <li><i>e.g.</i>, <tt>www.midiacom.uff.br</tt> é um apelido para <tt>mesbla.midiacom.uff.br</tt>.</li>
                    </ul></li>
                    <li><b>Tipo=MX</b>
                    <ul>
                        <li><b>valor</b> é o <span class="alert">nome do host</span> que funciona como servidor de e-mail do domínio associado ao <b>nome</b>.</li>
                    </ul></li>
                </ul>
            </div>
        </div>
    </div>
    </section>

    <section>
    <h1>DNS: Protocolo e Mensagens (I)</h1>
    <div class="slideContent">
        <ul>
            <li>Mensagens de <span class="alert">requisição</span> e <span class="alert">resposta</span> têm o mesmo <span class="alert">formato</span>.</li>
        </ul>
        <div>
            <div class="column" style="width: 50%;">
                <ul>
                    <li>Cabeçalho das mensagens:
                    <ul>
                        <li><b>Identificação</b>: # de 16 bits para requisição; resposta utiliza mesmo # da requisição a que responde.</li>
                        <li><b>Flags</b>:
                        <ul>
                            <li>Requisição ou resposta.</li>
                            <li>Modo recursivo é desejado.</li>
                            <li>Modo recursivo está disponível.</li>
                            <li>Resposta é autoritativa.</li>
                        </ul></li>
                    </ul></li>
                </ul>
            </div>
            <div class="column" style="width: 50%;">
                <center>
                    <object type="image/svg+xml" data="imagens/DNSMensagem.svg" style="width: 70%;"></object>
                </center>
            </div>
        </div>
    </div>
    </section>

    <section>
    <h1>DNS: Protocolo e Mensagens (II)</h1>
    <div class="slideContent">
        </div>
        <br>
        <br>
        <br>
        <div class="column" style="width: 50%;">
            <br>
            <br>
            <ul>
                <li>Campo das consultas:
                <ul>
                    <li>Múltiplas consultas possíveis em uma mesma requisição.</li>
                    <li>Informa nomes, tipos dos campos nas requisições.</li>
                </ul></li>
                <li>Campo das respostas:
                <ul>
                    <li>Múltiplas respostas possíveis em uma mesma mensagem.</li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
                <object type="image/svg+xml" data="imagens/DNSMensagem.svg" style="width: 70%;"></object>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>Inserindo Registros no DNS</h1>
    <div class="slideContent">
        <ul>
            <li>Exemplo: nova empresa chamada &ldquo;Network Utopia&rdquo;.</li>
            <li>Registro do domínio networkutopia.com com a entidade de registro de nomes.
            <ul>
                <li><i>e.g.</i>, Network Solutions.</li>
                <li>Necessário prover nomes e IPs dos servidores de nome autoritativos do novo domínio (primário e secundário).</li>
                <li>Entidade de registro insere dois RRs na base do servidor de DNS TLD <tt>.com</tt>:
                <ul>
                    <li><tt>(networkutopia.com, dns1.networkutopia.com, NS).</tt></li>
                    <li><tt>(dns1.networkutopia.com, 212.212.212.1, A)</tt>.</li>
                </ul></li>
            </ul></li>
            <li>No DNS autoritativo, são criadas RRs do tipo A para <tt>www.networkutopia.com</tt> e do tipo MX para o domínio.</li>
        </ul>
    </div>
    </section>

    <section>
    <h1>Registro de um Domínio</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <div id="termcastDominio" style="margin-left: 3px;"></div>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li>Usamos a ferramenta <tt>dig</tt> para fazer consultas ao DNS.</li>
                <li>Consulta inicial do tipo NS ao domínio <tt>uff.br</tt>.
                <ul>
                    <li>Resultado: três entradas listando servidores de DNS autoritativos.</li>
                </ul></li>
                <li>Segunda consulta: entrada do tipo A para <tt>server.uff.br</tt>.
                <ul>
                    <li>Resultado: endereço IP do servidor.</li>
                </ul></li>
                <li>Note que respostas <span class="alert">não são autoritativas</span>.
                <ul>
                    <li>Possivelmente um cache do servidor DNS local utilizado.</li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <script type="text/javascript">
            var TermCast4;
            DzAddPostInitFunction(function() {

                    TermCast4 = new TermCast(document.getElementById('termcastDominio'), 'terminalSessions/dominio.json');
            });
        </script>

    <section>
    <h1>Respostas Autoritativas <i>vs.</i> Não-autoritativas</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <div id="termcastAutoritativo" style="margin-left: 3px;"></div>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li>Mesma consulta repetida duas vezes:
                <ul>
                    <li>Do tipo A para nome <tt>www.midiacom.uff.br</tt>.</li>
                </ul></li>
                <li>Inicialmente, usamos um servidor local qualquer.
                <ul>
                    <li>Resultado: resposta <span class="alert">não-autoritativa</span>.</li>
                    <li>Possivelmente cache (pode estar desatualizada!).</li>
                </ul></li>
                <li>Segunda tentativa: usamos um dos servidores de DNS de <tt>uff.br</tt> como &ldquo;servidor local&rdquo;
                <ul>
                    <li>Resultado: <span class="alert">resposta autoritativa</span>.</li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <script type="text/javascript">
            var TermCast5;
            DzAddPostInitFunction(function() {

                    TermCast5 = new TermCast(document.getElementById('termcastAutoritativo'), 'terminalSessions/autoritativo.json');
            });
        </script>

    <section>
    <h1>DNS e E-mail</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <div id="termcastEmail" style="margin-left: 3px;"></div>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li>Como servidor de e-mail do remetente sabe qual o servidor de e-mail do destinatário?
                <ul>
                    <li>Endereço de e-mail associado a um domínio.</li>
                    <li><i>e.g.</i> <tt>user@exemplo.com</tt>.</li>
                    <li>Servidor do remetente faz consulta do tipo MX a domínio do destinatário.</li>
                </ul></li>
                <li>Consulta do tipo MX retorna um <span class="alert">nome</span>
                <ul>
                    <li>Ainda precisa de uma nova resolução.</li>
                    <li>Consulta do tipo A.</li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <script type="text/javascript">
            var TermCast6;
            DzAddPostInitFunction(function() {

                    TermCast6 = new TermCast(document.getElementById('termcastEmail'), 'terminalSessions/mail.json');
            });
        </script>

    <section>
    <h1>Atacando o DNS</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <ul>
                <li><b>Ataques de DDoS:</b>
                <ul>
                    <li>Bombardear servidores raiz com tráfego.
                    <ul>
                        <li>Até hoje, não foi bem sucedido.</li>
                        <li>Técnicas de filtro de tráfego.</li>
                        <li>Servidores de DNS locais fazem cache dos IPs dos servidores TLD, evitam acessos ao servidores raiz.</li>
                    </ul></li>
                    <li>Bombardear servidores TLD.
                    <ul>
                        <li>Potencialmente mais perigoso.</li>
                    </ul></li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li><b>Ataques de redirecionamento:</b>
                <ul>
                    <li>Homem-no-meio.
                    <ul>
                        <li>Intercepta requisições.</li>
                    </ul></li>
                    <li>Envenenamento do DNS.
                    <ul>
                        <li>Envia respostas adulteradas para servidor de DNS, que faz cache das informações.</li>
                    </ul></li>
                </ul></li>
                <li><b>Exploração do DNS para DDoS:</b>
                <ul>
                    <li>Envia requisições com IP de origem forjado (IP da vítima).</li>
                    <li>Requer amplificação.</li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

	<section class="secao">
    <div class="slideContent">
        Sockets
    </div>
    </section>

    <section>
    <h1>Programação com Sockets (I)</h1>
    <div class="slideContent">
        <ul>
            <li><b>Objetivo:</b> aprender a construir aplicações Cliente&mdash;Servidor que se comuniquem utilizando sockets.</li>
            <li><b>Socket:</b> janela entre processo da aplicação e protocolo de transporte.</li>
        </ul>
        <br>
        <br>
        <center>
            <object type="image/svg+xml" data="imagens/Sockets.svg" style="width: 70%;"></object>
        </center>

    </div>
    </section>

    <section>
    <h1>Programação com Sockets (II)</h1>
    <div class="slideContent">
        <ul>
            <li><b>Dois tipos de socket para dois modelos de serviço de transporte:</b>
            <ul>
            <li><span class="alert">UDP:</span> serviço de datagramas não-confiável.</li>
            <li><span class="alert">TCP:</span> serviço de entrega confiável, orientado a fluxo de bytes.</li>
            </ul></li>
            <li><b>Aplicação de exemplo</b>:
            <ol>
            <li>Cliente lê <i>string</i> do teclado e envia o dado para o servidor.</li>
            <li>O servidor recebe o dado e converte a <i>string</i> para caixa alta.</li>
            <li>Servidor envia dados modificados para o cliente.</li>
            <li>Cliente recebe dado modificado e imprime na tela.</li>
            </ol></li>
        </ul>
    </div>
    </section>

    <section>
    <h1>Programação com Sockets UDP</h1>
    <div class="slideContent">
        <ul>
        <li><b>UDP: não há &ldquo;conexão&rdquo; entre cliente e servidor.</b>
        <ul>
            <li>Não existe handshaking antes do envio de dados.</li>
            <li>Transmissor explicitamente informa o endereço IP e o número de porta de destino a cada pacote.</li>
            <li>Receptor extrai endereço IP do transmissor e número de porta do pacote recebido.</li>
        </ul></li>
        <li><span class="alert">UDP: dados transmitidos podem ser perdidos ou recebidos fora de ordem!</span></li>
        <li><b>Ponto de vista da aplicação:</b>
        <ul>
            <li>UDP provê serviço <b>não-confiável</b> de transmissão de grupos de bytes (&ldquo;datagramas&rdquo;) entre cliente e servidor.</li>
        </ul></li>
        </ul>
    </div>
    </section>

    <section>
    <h1>Interação entre Cliente/Servidor e o Socket: UDP</h1>
    <div class="slideContent">
        <center>
        <object type="image/svg+xml" data="imagens/ClienteServidorUDP.svg" style="width: 70%;"></object>
        </center>
    </div>
    </section>

    <section>
    <h1>Aplicação de Exemplo: Cliente UDP</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
from socket import *

serverName = 'localhost'
serverPort = 12000

# Criacao do socket
clientSocket = socket(AF_INET, SOCK_DGRAM)

sentence = raw_input('Input lowercase sentence:')

# Envio de bytes. Repare que o endereco do destinatario eh necessario
clientSocket.sendto(sentence, (serverName, serverPort))

# Recepcao
modifiedSentence, addr = clientSocket.recvfrom(1024)
print 'From Server {}: {}'.format(addr, modifiedSentence)

# Fechamento
clientSocket.close()
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Aplicação de Exemplo: Servidor UDP (I)</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
from socket import *

# Numero de porta na qual o servidor estara esperando conexoes.
serverPort = 12000

# Criar o socket. AF_INET e SOCK_DGRAM indicam UDP.
serverSocket = socket(AF_INET, SOCK_DGRAM)

# Associar o socket a porta escolhida. Primeiro argumento vazio indica
# que desejamos aceitar conexoes em qualquer interface de rede desse host
serverSocket.bind(('', serverPort))

print 'O servidor esta pronto para receber pacotes.'

# Loop infinito: servidor eh capaz de tratar multiplas conexoes
while 1:
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Aplicação de Exemplo: Servidor UDP (II)</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
    # Aguardar novo pacote
    print 'Aguardando pacote...'
    sentence, addr = serverSocket.recvfrom(1024)
    print 'Nova pacote recebido!'

    # Processamento
    capitalizedSentence = sentence.upper()

    # Envio. Repare que o endereco do destinatario eh necessario.
    print 'Realizando envio...'
    serverSocket.sendto(capitalizedSentence, addr)

# Fechamento
print 'Fechando socket...'
serverSocket.close()
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Programação com Sockets TCP</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <ul>
            <li><span class="alert">Cliente deve contactar servidor</span>.
            <ul>
                <li>Processo do servidor precisa estar previamente em execução.</li>
                <li>Servidor precisa ter criado socket que aceitará contato do cliente.</li>
            </ul></li>
            <li><span class="alert">Cliente contacta servidor:</span>
            <ul>
                <li>Criando socket TCP, especificando IP e número de porta do processo servidor.</li>
                <li><span class="alert">Quando cliente cria o socket</span>: TCP do cliente estabelece conexão para o TCP do servidor.</li>
            </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
            <li>Quando contactado pelo cliente, <span class="alert">TCP do servidor cria um novo socket</span>.
            <ul>
                <li>Novo socket utilizado para a comunicação do processo servidor com o processo cliente.</li>
                <li>Este esquema de dois sockets permite ao servidor falar com múltiplos clientes.</li>
                <li>Número de porta <span class="alert">de origem</span> são usados para distinguir clientes.
                <ul>
                <li>Mais detalhes no próximo capítulo</li>
                </ul></li>
            </ul></li>
            <li><b>Ponto de vista da aplicação:</b>
            <ul>
                <li>TCP provê transferência confiável e ordenada de fluxo de bytes entre cliente e servidor.</li>
            </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <section>
    <h1>Interação entre Cliente/Servidor e Socket TCP</h1>
    <div class="slideContent">
        <center>
        <object type="image/svg+xml" data="imagens/ClienteServidorTCP.svg" style="width: 70%;"></object>
        </center>
    </div>
    </section>

    <section>
    <h1>Aplicação de Exemplo: Cliente TCP</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
from socket import *

serverName = 'localhost'
serverPort = 12000

# Criacao do socket
clientSocket = socket(AF_INET, SOCK_STREAM)
# Conexao com o servidor
clientSocket.connect((serverName,serverPort))

sentence = raw_input('Input lowercase sentence:')
# Envio de bytes
clientSocket.send(sentence)

# Recepcao
modifiedSentence = clientSocket.recv(1024)
print 'From Server:', modifiedSentence

# Fechamento
clientSocket.close()
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Aplicação de Exemplo: Servidor TCP (I)</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
from socket import *

# Numero de porta na qual o servidor estara esperando conexoes.
serverPort = 12000

# Criar o socket. AF_INET e SOCK_STREAM indicam TCP.
serverSocket = socket(AF_INET, SOCK_STREAM)

# Associar o socket a porta escolhida. Primeiro argumento vazio indica
# que desejamos aceitar conexoes em qualquer interface de rede desse host
serverSocket.bind(('', serverPort))

# Habilitar socket para aceitar conexoes. O argumento 1 indica que ate
# uma conexao sera deixada em espera, caso recebamos multiplas conexoes
# simultaneas
serverSocket.listen(1)

print 'O servidor esta pronto para receber conexoes'

# Loop infinito: servidor eh capaz de tratar multiplas conexoes
while 1:

            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Aplicação de Exemplo: Servidor TCP (II)</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
    # Aguardar nova conexao
    print 'Aguardando conexao...'
    connectionSocket, addr = serverSocket.accept()
    print 'Nova conexao recebida!'

    # Recepcao de dados
    print 'Aguardando dados...'
    sentence = connectionSocket.recv(1024)

    print 'Dado recebido do cliente'
    # Processamento
    capitalizedSentence = sentence.upper()
    # Envio
    print 'Realizando envio...'
    connectionSocket.send(capitalizedSentence)
    # Fechamento
    print 'Fechando socket...'
    connectionSocket.close()

            </code>
        </pre>
    </div>
    </section>


    <section class="secao">
    <div class="slideContent">
        Exemplos Mais Complexos
    </div>
    </section>
    <section>
        <h1>Um (Protótipo de) Servidor Web (I)</h1>
        <div class="slideContent">
            <pre>
                <code class="python" style="font-size: 20px;">
# Numero de porta na qual o servidor estara esperando conexoes.
serverPort = 8001

# Criar o socket. AF_INET e SOCK_STREAM indicam TCP.
serverSocket = socket(AF_INET, SOCK_STREAM)

# Associar o socket a porta escolhida. Primeiro argumento vazio indica
# que desejamos aceitar conexoes em qualquer interface de rede desse host
serverSocket.bind(('', serverPort))

# Habilitar socket para aceitar conexoes. O argumento 1 indica que ate
# uma conexao sera deixada em espera, caso recebamos multiplas conexoes
# simultaneas
serverSocket.listen(1)

# Loop infinito: servidor eh capaz de tratar multiplas conexoes
while 1:

    # Aguardar nova conexao
    connectionSocket, addr = serverSocket.accept()

    # Tratamento da conexao encapsulado em uma funcao
    trataConexao(connectionSocket)
                </code>
            </pre>
        </div>
    </section>

    <section>
        <h1>Um (Protótipo de) Servidor Web (II)</h1>
        <div class="slideContent">
            <pre>
                <code class="python" style="font-size: 20px;">
from socket import *
import os
import re

def trataConexao(s):

    # Podemos tratar um socket como um arquivo.
    sf = s.makefile()
    # Primeira linha deve informar a requisicao. Ignoraremos as demais (e.g., cabecalhos).
    requestMessageLine = sf.readline()
    # Campos sao divididos por espacos em branco. Primeiro campo deve ser tipo
        # do metodo. Neste prototipo, tratamos apenas requisicoes do tipo GET.
    tokens = requestMessageLine.split()
    if tokens[0] == "GET":

        # Proximo campo eh o caminho do objeto requisitado.
        filename = tokens[1]

        # Arquivos servidos pelo servidor web sao confinados ao diretorio do qual ele eh
                # executado (e subdiretorios). Logo, se a requisicao referencia um caminho
                # absoluto (i.e., iniciado por '/'), precisamos transformar isso em relativo
        if filename[0] == '/':
            filename = filename[1:]
                </code>
            </pre>
        </div>
    </section>

    <section>
        <h1>Um (Protótipo de) Servidor Web (III)</h1>
        <div class="slideContent">
            <pre>
                <code class="python" style="font-size: 20px;">
        # Requisitamos a leitura do arquivo a partir do sistema de arquivos local.
        if os.path.isfile(filename):

            # Levantar informacoes sobre o objeto
            statinfo = os.stat(filename)
            f = open(filename)
            # Montar a saida
            s.send('HTTP/1.0 200 OK\r\n')
            # Precisamos de algumas linhas de cabecalho. A primeira eh o tipo
            # do objeto.
            if re.search('.jpg$', filename):
                s.send('Content-Type: image/jpeg\r\n')
            elif re.search('.gif$', filename):
                s.send('Content-Type: image/gif\r\n')
            elif re.search('.html$', filename):
                s.send('Content-Type: text/html\r\n')
            elif re.search('.js$', filename):
                s.send('Content-Type: text/js\r\n')
            elif re.search('.css$', filename):
                s.send('Content-Type: text/css\r\n')
            else:
                s.send('Content-Type: application/octet-stream\r\n')
                </code>
            </pre>
        </div>
    </section>

    <section>
        <h1>Um (Protótipo de) Servidor Web (IV)</h1>
        <div class="slideContent">
            <pre>
                <code class="python" style="font-size: 20px;">
            # Precisamos tambem do tamanho do objeto
            s.send('Content-Length: {}\r\n'.format(statinfo.st_size))

            # Cabecalho eh separado do corpo da mensagem por uma linha em branco
            s.send('\r\n')

            # Agora enviamos o conteudo do arquivo no corpo da mensagem
            s.send(f.read())
        else:

            # Se o arquivo nao foi encontrado.
            s.send('HTTP/1.0 404 Not Found\r\n')
    else:

        # Tratamento (muito basico) de erros
        print 'Requisicao nao compreendida!'

    s.close()
                </code>
            </pre>
        </div>
    </section>

    <section>
    <h1>Ferramenta de Medição de Vazão TCP: Cliente (I)</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
from socket import *
import sys
import time

# Leitura do endereco do servidor
serverName = sys.argv[1]
serverPort = 6789

# Criacao do socket
clientSocket = socket(AF_INET, SOCK_STREAM)
# Conexao com o servidor
clientSocket.connect((serverName,serverPort))

# Criacao de um buffer para envio pelo socket. O conteudo nao eh importante.
buffer = bytearray(8192)

# Pegar o horario atual para sabermos quando terminar o teste.
now = int(round(time.time() * 1000))

# Teste sempre dura 10 segundos = 10000 ms.
end = now + 10000
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Ferramenta de Medição de Vazão TCP: Cliente (II)</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
# Variavel i guarda o numero de vezes que o buffer foi escrito no socket.
# Auxiliara no calculo da vazao.
i = 0
while True:
    # Envio de bytes
    clientSocket.send(buffer)
    i = i + 1
    now = int(round(time.time() * 1000))
    if now >= end:
        break

# Calcular e imprimir a vazao. A cada iteracao do loop anterior, transmitimos
# 64 kb. Para calcular vazao, basta multiplicar i por 64 e dividir por 10.
print "Vazao media durante o teste foi de {} kb/s".format(i * 64 / 10.0)

# Fechamento
clientSocket.close()
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Ferramenta de Medição de Vazão TCP: Servidor (I)</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
from socket import *

serverPort = 6789

# Criacao do socket.
serverSocket = socket(AF_INET,SOCK_STREAM)

# Associacao do socket a porta correta.
serverSocket.bind(('',serverPort))

# Habilitar escuta por conexoes.
serverSocket.listen(1)
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Ferramenta de Medição de Vazão TCP: Servidor (II)</h1>
    <div class="slideContent">
        <pre>
            <code class="python" style="font-size: 20px;">
# Loop infinito para tratar multiplas conexoes
while 1:

    print 'Aguardando conexao...'
    # Aguardar nova conexao
    connectionSocket, addr = serverSocket.accept()

    print 'Conexao recebida.'

    # Recepcao de dados
    while True:
        try:
            # Leitura dos dados
            buffer = connectionSocket.recv(8192)
        except socket.error, exc:
            # Houve algum erro. Assumimos que a conexao foi fechada
            break

    connectionSocket.close()
    print 'Conexao encerrada'
            </code>
        </pre>
    </div>
    </section>

    <section class="secao">
    <div class="slideContent">
        Outras Linguagens: Funções/Métodos Típicos
    </div>
    </section>

    <section>
    <h1>Funções/Métodos Tipicamente Utilizados</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
        <center>
            <span class="alert">Cliente</span>
        </center>
        <ul>
            <li><b>socket():</b> criar novo socket de um determinado tipo.</li>
            <li><b>write():</b> &ldquo;passa&rdquo; dados/mensagens pelo socket p/ transporte.</li>
            <li><b>sendto():</b> envia mensagem por socket sem conexão (UDP).</li>
            <li><b>read():</b> &ldquo;recebe&rdquo; dados/mensagens pelo socket do transporte.</li>
            <li><b>recvfrom():</b> recebe mensagem por socket sem conexão (UDP).</li>
            <li><b>connect():</b> abre uma conexão (TCP) para servidor/porta especificados.</li>
            <li><b>getByName() ou getHostByName():</b> resolve nome para endereço IP.</li>
            <li><b>close():</b> fecha o socket (e conexão, se aplicável).</li>
        </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
            <span class="alert">Servidor</span>
            </center>
            <ul>
            <li><b>socket():</b> criar novo socket de um determinado tipo.</li>
            <li><b>write():</b> &ldquo;passa&rdquo; dados/mensagens pelo socket p/ transporte.</li>
            <li><b>sendto():</b> envia mensagem por socket sem conexão (UDP).</li>
            <li><b>read():</b> &ldquo;recebe&rdquo; dados/mensagens pelo socket do transporte.</li>
            <li><b>recvfrom():</b> recebe mensagem por socket sem conexão (UDP).</li>
            <li><b>bind():</b> associa socket à porta especificada.</li>
                <li><b>listen():</b> habilita socket (TCP) a receber conexões.</li>
            <li><b>close():</b> fecha o socket (e conexão, se aplicável).</li>
            </ul>
        </div>
    </div>
    </section>

    <section>
    <h1>Sockets em Outras Linguagens: Java (Cliente TCP, I)</h1>
    <div class="slideContent">
        <pre>
            <code class="java" style="font-size: 20px;">
import java.io.*;
import java.net.*;

class TCPClient {

    public static void main(String argv[]) throws Exception {

        String sentence;
    String modifiedSentence;

    BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));

        // Criação do socket TCP. Note que aqui, diferentemente da versão UDP, já especificamos
        // o endereço do servidor (nome do host/ip e porta).
        Socket clientSocket = new Socket("hostname", 6789);

        // Do ponto de vista do programador, um socket TCP pode ser manipulado de forma similar
        // a um arquivo, com escrita e leitura de um fluxo de bytes.
        DataOutputStream outToServer = new DataOutputStream(clientSocket.getOutputStream());
        BufferedReader inFromServer =  new BufferedReader(new InputStreamReader(
                                                          clientSocket.getInputStream()));
        // Leitura da entrada do usuário.
        sentence = inFromUser.readLine();
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Sockets em Outras Linguagens: Java (Cliente TCP, II)</h1>
    <div class="slideContent">
        <pre>
            <code class="java" style="font-size: 20px;">
        // String é simplesmente "escrita" no socket. Notem que adicionamos uma quebra de
        // linha ao final da string (caractere '\n'). Isso demarcará ao servidor onde termina 
        // a mensagem a ser processada.
        outToServer.writeBytes(sentence + '\n');

        // Aguardamos uma resposta do servidor. Note mais uma vez a manipulação do socket como
        // se fosse um arquivo. Aqui também uma quebra de linha denota fim da mensagem. Por
        // fim, assim como no cliente UDP, leituras são (geralmente) bloqueantes.
        modifiedSentence = inFromServer.readLine();

        // Impressão do resultado da tela.
        System.out.println("FROM SERVER: " + modifiedSentence);

        // Fechamento do socket.
        clientSocket.close();
    }
}
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Sockets em Outras Linguagens: Java (Servidor TCP, I)</h1>
    <div class="slideContent">
        <pre>
            <code class="java" style="font-size: 20px;">
import java.io.*;
import java.net.*;

class TCPServer {

    public static void main(String argv[]) throws Exception {
        String clientSentence;
        String capitalizedSentence;

        // Criação do socket do servidor. Este socket será usado para esperar por novas
        // conexões. Repare que especificamos um # de porta na qual desejamos esperar
        // pelas conexões.
        ServerSocket welcomeSocket = new ServerSocket(6789);

        // Assim como o servidor UDP, servidor TCP também executa um loop infinito permitindo
        // o atendimento de múltiplos clientes.
        while(true) {

            // Função/método accept(): executada sobre socket, diz ao SO para aguardar (e
            // aceitar) novas conexões. Só faz sentindo para sockets orientados a conexão
            // (TCP). Note que o resultado da função/método é um novo socket.
            Socket connectionSocket = welcomeSocket.accept();
            </code>
        </pre>
    </div>
    </section>

    <section>
    <h1>Sockets em Outras Linguagens: Java (Servidor TCP, II)</h1>
    <div class="slideContent">
        <pre>
            <code class="java" style="font-size: 20px;">
            // O socket original é serve apenas para aguardar por novas conexões. Já o socket
            // retornado pela função/método accept representa uma conexão, realmente. É dele
            // que "leremos" os dados enviados pelo cliente e escreveremos os dados de
            // resposta. Mais uma vez, note a abstração de arquivo.
            BufferedReader inFromClient = new BufferedReader(new
                                        InputStreamReader(connectionSocket.getInputStream()));
            DataOutputStream  outToClient = new DataOutputStream(
                                            connectionSocket.getOutputStream());

            // Aguardamos dados do cliente. Por convenção, dados terminam em uma quebra
            // linha.
            clientSentence = inFromClient.readLine();

            // Implementação da lógica da aplicação.
            capitalizedSentence = clientSentence.toUpperCase() + '\n';

            // Escrita do resultado no socket.
            outToClient.writeBytes(capitalizedSentence);
        }
    }
}
            </code>
        </pre>
    </div>
    </section>

	<section class="secao">
    <div class="slideContent">
        Serviços da Camada de Transporte
    </div>
    </section>

    <section>
    <h1>Serviços e Protocolos de Transporte</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <ul>
                <li>Provê <span class="alert">comunicação lógica</span> entre <span class="alert">processos</span> da aplicação rodando em <i>hosts</i> diferentes.</li>
                <li>Protocolos de transporte <span class="alert">são executados nos sistemas finais</span>.
                <ul>
                <li>Lado transmissor: quebra mensagens da aplicação em <span class="alert">segmentos</span>, passa segmentos para camada de rede.</li>
                <li>Lado receptor: remonta segmentos para formar mensagens originais, passa mensagens para a camada de aplicação.</li>
                </ul></li>
                <li>Mais de um protocolo disponível para as aplicações.
                <ul>
                <li>Na Internet: TCP e UDP.</li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
                <object type="image/svg+xml" data="imagens/CamadaDeTransporte.svg" style="width: 70%;"></object>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>Camada de Transporte <i>vs.</i> Camada de Rede</h1>
    <div class="slideContent">
        <div class="column" style="width: 40%;">
            <ul>
                <li><b>Camada de Rede:</b> comunicação lógica entre <i>hosts</i>.</li>
                <li><b>Camada de Transporte:</b> comunicação lógica entre processos.
                <ul>
                <li>Depende de, e aperfeiçoa, serviços da camada de rede.</li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 60%;">
            <center>
            <div class="block" style="width:600px;">
                <div class="blockTitle" style="width: 100%;">
                    <p>Analogia doméstica</p>
                </div>
                <div class="blockBody">
                    <ul>
                        <li>12 crianças na casa da Ann enviam cartas a 12 crianças na casa do Bill.
                        <ul>
                        <li><i>hosts</i> = casas.</li>
                        <li>processos = crianças.</li>
                        <li>mensagens da aplicação = cartas nos envelopes.</li>
                        <li>protocolo de transporte = Ann e Bill que demultiplexam cartas para as crianças.</li>
                        <li>protocolo de camada de rede = correios.</li>
                        </ul></li>
                    </ul>
                </div>
            </div>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>Protocolos de Camada de Transporte da Internet</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <ul>
                <li>Entrega confiável, em ordem (TCP).
                <ul>
                <li>Controle de congestionamento.</li>
                <li>Controle de fluxo.</li>
                <li><i>Setup</i> da conexão.</li>
                </ul></li>
                <li>Entrega não-confiável, não-ordenada (UDP).
                <ul>
                <li>Extensão básica do serviço de &ldquo;melhor esforço&rdquo; do IP.</li>
                </ul></li>
                <li>Serviços não disponíveis (nem TCP, nem UDP):
                <ul>
                <li>Garantias de atraso máximo.</li>
                <li>Garantias de vazão mínima.</li>
                </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
                <object type="image/svg+xml" data="imagens/CamadaDeTransporte.svg" style="width: 70%;"></object>
            </center>
        </div>
    </div>
    </section>

    <section class="secao">
    <div class="slideContent">
        Multiplexação e Demultiplexação
    </div>
    </section>

    <section>
    <h1>Multiplexação/Demultiplexação</h1>
    <div class="slideContent">
        <div style="height: 200px;">
            <div class="column" style="width: 50%;">
                <center>
                    <div class="block" style="width:550px;">
                        <div class="blockTitle" style="width: 100%;">
                            <p>Multiplexação no Transmissor</p>
                        </div>
                        <div class="blockBody">
                            Lida com dados de múltiplos sockets, adiciona cabeçalho da camada de transporte (usado posteriormente para demultiplexação)
                        </div>
                    </div>
                </center>
            </div>
            <div class="column" style="width: 50%;">
                <center>
                    <div class="block" style="width:550px;">
                        <div class="blockTitle" style="width: 100%;">
                            <p>Demultiplexação no Receptor</p>
                        </div>
                        <div class="blockBody">
                            Usa informação do cabeçalho para entregar segmentos recebidos para o socket correto
                        </div>
                    </div>
                </center>
            </div>
        </div>
        <center>
            <object type="image/svg+xml" data="imagens/Multiplexacao.svg" style="width: 80%;"></object>
        </center>
    </div>
    </section>

    <section>
    <h1>Como a Demultiplexação Ocorre</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <ul>
                <li><i>Host</i> recebe datagrama IP.
                <ul>
                <li>Cada datagrama possui um endereço IP de origem, endereço IP de destino.</li>
                <li>Cada datagrama carrega um segmento de camada de transporte.</li>
                <li>Cada segmento possui <span class="alert">números de porta de origem e de destino</span>.</li>
                </ul></li>
                <li><i>Host</i> utiliza <span class="alert">tanto os endereços IP quanto os números de porta</span> para direcionar segmentos aos sockets apropriados.</li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
                <object type="image/svg+xml" data="imagens/CabecalhoGenerico.svg" style="width: 70%;"></object>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>Demultiplexação Sem Conexão</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
        <ul>
            <li><b>Lembre-se:</b> socket criado tem # de porta no <i>host</i>.</li>
                <tt>DatagramSocket mySocket1 = new DatagramSocket(12534);</tt>
            <li><b>Lembre-se:</b> quando criamos datagrama para enviar pelo socket UDP, é preciso especificar:
            <ul>
            <li>Endereço IP de destino.</li>
            <li># de porta de destino.</li>
            </ul></li>
        </ul>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
            <li>Quando <i>host</i> recebe segmento UDP:
            <ul>
                <li>Verifica o # de porta de destino no segmento.</li>
                <li>Direciona o segmento UDP para o socket com aquele # de porta.</li>
            </ul></li>
            <li>Datagramas com <span class="alert">o mesmo # de porta de destino</span>, mas com IPs e/ou portas de origem diferentes serão direcionados <span class="alert">ao mesmo socket</span> no destinatário.</li>
            </ul>
        </div>
    </div>
    </section>

    <section>
    <h1>Demultiplexação Sem Conexão: Exemplo</h1>
    <div class="slideContent">
        <center>
        <object type="image/svg+xml" data="imagens/DemultiplexacaoSemConexao.svg" style="width: 80%;"></object>
        </center>
    </div>
    </section>

    <section>
    <h1>Demultiplexação Orientada a Conexão</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <ul>
                <li>Socket TCP é identificado por tupla de 4 componentes:
                <ul>
                <li><span class="alert">IP de origem</span>.</li>
                <li><span class="alert">IP de destino</span>.</li>
                <li><span class="alert">Porta de origem</span>.</li>
                <li><span class="alert">Porta de destino</span>.</li>
                </ul></li>
                <li>Demultiplexação: receptor usa todos os quatro valores para direcionar segmento a socket correto.</li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
                <li><i>Host</i> servidor pode suportar múltiplos sockets TCP simultâneos.
                <ul>
                <li>Cada socket identificado pela sua própria tupla de quatro valores.</li>
                </ul></li>
                <li>Servidores web têm sockets diferentes para cada cliente conectado.
                <ul>
                <li>No HTTP não-persistente, um socket para cada requisição.</li>
                </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <section>
    <h1>Demultiplexação Orientada a Conexão: Exemplo</h1>
    <div class="slideContent">
        <center>
        <object type="image/svg+xml" data="imagens/DemultiplexacaoConectada.svg" style="width: 80%;"></object>
        </center>
        <br>
        <div style="padding: 10px; width: 60%;">
            <span class="alert">Três segmentos, todos destinados ao IP de B na porta de destino 80 são demultiplexados para sockets diferentes.</span>
        </div>
    </div>
    </section>

    <section>
    <h1>Demultiplexação Orientada a Conexão: Exemplo (Threads)</h1>
    <div class="slideContent">
        <center>
        <object type="image/svg+xml" data="imagens/DemultiplexacaoConectadaThreads.svg" style="width: 80%;"></object>
        </center>
        <br>
        <br>
    </div>
    </section>

    <section class="secao">
    <div class="slideContent">
        Transporte Sem Conexão: UDP
    </div>
    </section>

    <section>
    <h1>UDP: <i>User Datagram Protocol</i> [RFC 768]</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
        <ul>
            <li>&ldquo;Serviço básico&rdquo;, &ldquo;mínimo&rdquo; da camada de transporte da Internet.</li>
            <li>Modelo de serviço de &ldquo;melhor esforço&rdquo;.</li>
            <li>Segmentos UDP podem ser:
            <ul>
            <li>Perdidos</li>
            <li>Entregues, porém fora de ordem para a aplicação.</li>
            </ul></li>
            <li><span class="alert">Sem conexão:</span>
            <ul>
            <li>Não há comunicação inicial entre UDP do transmissor e do receptor.</li>
            <li>Datagramas são simplesmente enviados.</li>
            <li>Cada segmento UDP é tratado de forma completamente independente dos demais.</li>
            </ul></li>
        </ul>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
            <li>Usos do UDP:
            <ul>
                <li>Aplicações de <i>Streaming</i> multimídia (tolerantes a perda, sensíveis a taxa).</li>
                <li>DNS.</li>
                <li>SNMP.</li>
            </ul></li>
            <li>Transferência confiável sobre UDP:
            <ul>
                <li>Possível, mas depende da aplicação.</li>
                <li>Adição de confiabilidade da própria aplicação.</li>
                <li>Métodos de recuperação de erros específicos de cada aplicação.</li>
            </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <section>
    <h1>UDP: Cabeçalho de um Segmento</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
            <center>
                <object type="image/svg+xml" data="imagens/UDPFormato.svg" style="width: 70%;"></object>
            </center>
            <ul>
                <li><span class="alert">Campo <i>length</i></span>: tamanho do segmento, incluindo cabeçalhos.</li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <center>
            <br>
            <br>
            <div class="block" style="width:550px;">
                <div class="blockTitle" style="width: 100%;">
                    <p>Por que existe um UDP?</p>
                </div>
                <div class="blockBody">
                    <ul>
                        <li>Sem estabelecimento de conexão (que adiciona atraso).</li>
                        <li>Simples: não armazena estado da comunicação no transmissor ou no receptor.</li>
                        <li>Cabeçalho pequeno.</li>
                        <li>Sem controle de congestionamento: UDP transmite na mesma taxa que a aplicação gera.</li>
                    </ul>
                </div>
            </div>
            </center>
        </div>
    </div>
    </section>

    <section>
    <h1>UDP: <i>Checksum</i></h1>
    <div class="slideContent">
        <ul>
        <li><b>Objetivo:</b> detectar &ldquo;erros&rdquo; (<i>e.g.</i>, bits com valor trocado) no segmento transmitido.</li>
        </ul>
        <br>
        <div class="column" style="width: 50%;">
            <ul>
            <li><b>Transmissor:</b>
            <ul>
                <li>Trata conteúdo do segmento, incluindo campos de cabeçalho, como uma sequência de inteiros de 16 bits.</li>
                <li><i>Checksum</i>: soma, em complemento a 1, do conteúdo do segmento.</li>
                <li>Transmissor coloca valor do <i>checksum</i> no campo do cabeçalho UDP.</li>
            </ul></li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <ul>
            <li><b>Receptor:</b>
            <ul>
                <li>Computa o <i>checksum</i> do segmento recebido.</li>
                <li><i>Checksum</i> computado é igual ao indicado pelo cabeçalho?
                <ul>
                <li>Não: erro detectado.</li>
                <li>Sim: nenhum erro detectado.
                <ul>
                    <li>Mas pode haver erros mesmo assim?</li>
                </ul></li>
                </ul></li>
            </ul></li>
            </ul>
        </div>
    </div>
    </section>

    <section>
    <h1><i>Checksum</i> da Internet: Soma em Complemento a 1</h1>
    <div class="slideContent">
            <ul>
            <li>Soma de dois valores de 16 bits em complemento a 1:</li>
            </ul>
            <br>
            <center>
                <object type="image/svg+xml" data="imagens/SomaComplementoA1.svg" style="width: 70%;"></object>
            </center>
            <br>
            <ul>
                <li>Note: ao somar dois números, o <i>vai-um</i> do bit mais significativo deve ser somado ao resultado.</li>
            </ul>
    </div>
    </section>

    <section>
    <h1>Internet Checksum: Exemplos</h1>
    <div class="slideContent">
        <div class="column" style="width: 50%;">
                <script type="text/javascript" >
                    var exemploLanternaASCII = '';
                    var exemploLanternaTempo;

                    function exemploChecksumZeraTabelaEntrada(l) {

                        var tabela = document.getElementById('exemploChecksumInputBits');
                        var tr, td;
                        var i, j;

                        tabela.innerHTML = "";
                        for (var i = 0; i < l; i++) {

                            if (i % 2 == 0) {

                                tr = document.createElement('tr');
                                tabela.appendChild(tr);

                                if (i > 0) {

                                    td = document.createElement('td');
                                    tr.appendChild(td);
                                    td.style.width = "15px";
                                    td.innerHTML = "+";
                                }
                                else {

                                    td = document.createElement('td');
                                    tr.appendChild(td);
                                    td.style.width = "15px";
                                    td.innerHTML = "";
                                }
                            }
                            else {

                                td = document.createElement('td');
                                tr.appendChild(td);
                                td.style.width = "15px";
                            }

                            for (j = 0; j < 8; j++) {

                                td = document.createElement('td');
                                tr.appendChild(td);
                                td.id = 'checksumInputByte' + i + 'Bit' + j;
                                td.style.width = "15px";
                                td.style.height = "15px";
                                td.style.textAlign = "center";
                            }

                            if (i % 2 == 1) {

                                td = document.createElement('td');
                                tr.appendChild(td);
                                td.style.width = "190px";
                                td.innerHTML = "&nbsp;&nbsp;&nbsp;(bytes " + (i+1) + " e " + (i) + ")";

                                if (i == 3 || (i > 3)) {

                                    tr.style.borderBottom = "2px solid #000";

                                    tr = document.createElement('tr');
                                    tabela.appendChild(tr);
                                    tr.style.color = "#11c";

                                    td = document.createElement('td');
                                    tr.appendChild(td);
                                    td.style.width = "15px";
                                    td.id = 'checksumInputParcelaCarry' + ((i-3)/2) + 'Bit0';
                                    td.innerHTML = "0";

                                    for (j = 0; j < 16; j++) {

                                        if (j == 8) {

                                            td = document.createElement('td');
                                            tr.appendChild(td);
                                            td.style.width = "15px";
                                        }

                                        td = document.createElement('td');
                                        tr.appendChild(td);
                                        td.id = 'checksumInputParcelaCarry' + ((i-3)/2) + 'Bit' + (j+1);
                                        td.style.width = "15px";
                                        td.style.height = "15px";
                                        td.style.textAlign = "center";
                                        td.innerHTML = "1";
                                    }

                                    td = document.createElement('td');
                                    tr.appendChild(td);
                                    td.style.width = "210px";
                                    td.innerHTML = "&nbsp;&nbsp;&nbsp;(com vai-1)";

                                    tr = document.createElement('tr');
                                    tabela.appendChild(tr);
                                    tr.style.color = "#c11";

                                    td = document.createElement('td');
                                    tr.appendChild(td);
                                    td.style.width = "15px";
                                    td.innerHTML = "";

                                    for (j = 0; j < 16; j++) {

                                        if (j == 8) {

                                            td = document.createElement('td');
                                            tr.appendChild(td);
                                            td.style.width = "15px";
                                        }

                                        td = document.createElement('td');
                                        tr.appendChild(td);
                                        td.id = 'checksumInputParcela' + ((i-3)/2) + 'Bit' + j;
                                        td.style.width = "15px";
                                        td.style.height = "15px";
                                        td.style.textAlign = "center";
                                        td.innerHTML = "1";
                                    }

                                    td = document.createElement('td');
                                    tr.appendChild(td);
                                    td.style.width = "190px";

                                    if (i < l - 1)
                                        td.innerHTML = "&nbsp;&nbsp;&nbsp;(parcela)";
                                    else
                                        td.innerHTML = "&nbsp;&nbsp;&nbsp;(total)";

                                }
                            }
                        }

                        tr.style.borderBottom = "2px solid #000";
                        tr.children[0].innerHTML = "~";

                        tr = document.createElement('tr');
                        tabela.appendChild(tr);
                        tr.style.color = "#1c1";

                        td = document.createElement('td');
                        tr.appendChild(td);
                        td.style.width = "15px";
                        td.innerHTML = "";

                        for (j = 0; j < 16; j++) {

                            if (j == 8) {

                                td = document.createElement('td');
                                tr.appendChild(td);
                                td.style.width = "15px";
                            }

                            td = document.createElement('td');
                            tr.appendChild(td);
                            td.id = 'checksumInputFinalBit' + j;
                            td.style.width = "15px";
                            td.style.height = "15px";
                            td.style.textAlign = "center";
                            td.innerHTML = "0";
                        }

                        td = document.createElement('td');
                        tr.appendChild(td);
                        td.style.width = "190px";
                        td.innerHTML = "&nbsp;&nbsp;&nbsp;(checksum)";
                    }

                    function exemploChecksumPreencheTabelaParcelaCarry(parcela, valor) {

                        var base2;
                        var bit;
                        var td;
                        var i;

                        base2 = valor.toString(2);
                        var padLen = 17 - base2.length;
                        for (i = 0; i < padLen; i++) base2 = "0" + base2;

                        for (bit = 0; bit < 17; bit++) {
                            td = document.getElementById('checksumInputParcelaCarry' + parcela + 'Bit' + bit);
                            td.innerHTML = base2.charAt(bit);
                        }
                    }

                    function exemploChecksumPreencheTabelaParcelaSemCarry(parcela, valor) {

                        var base2;
                        var bit;
                        var td;
                        var i;

                        base2 = valor.toString(2);
                        var padLen = 16 - base2.length;
                        for (i = 0; i < padLen; i++) base2 = "0" + base2;

                        for (bit = 0; bit < 16; bit++) {
                            td = document.getElementById('checksumInputParcela' + parcela + 'Bit' + bit);
                            td.innerHTML = base2.charAt(bit);
                        }
                    }

                    function exemploChecksumPreencheTabelaFinal(valor) {

                        var base2;
                        var bit;
                        var td;
                        var i;

                        base2 = valor.toString(2);
                        var padLen = 16 - base2.length;
                        for (i = 0; i < padLen; i++) base2 = "0" + base2;

                        for (bit = 0; bit < 16; bit++) {
                            td = document.getElementById('checksumInputFinalBit' + bit);
                            td.innerHTML = base2.charAt(bit);
                        }
                    }

                    function exemploChecksumPreencheTabelaEntrada(s) {

                        var byte, bit;
                        var ascii;
                        var entradaTabela;
                        var i;

                        if (s.length % 2 == 0)
                            exemploChecksumZeraTabelaEntrada(s.length);
                        else
                            exemploChecksumZeraTabelaEntrada(s.length + 1);

                        for (byte = 0; byte < s.length; byte += 2) {

                            if (byte + 1 < s.length) {

                                ascii = s.charCodeAt(byte + 1).toString(2);
                                var padLen = 8 - ascii.length;
                                for (i = 0; i < padLen; i++) ascii = "0" + ascii;
                            }
                            else {

                                ascii = "00000000";
                            }

                            for (bit = 0; bit < 8; bit++) {
                                entradaTabela = document.getElementById('checksumInputByte' + byte + 'Bit' + bit);
                                entradaTabela.innerHTML = ascii.charAt(bit);
                            }

                            ascii = s.charCodeAt(byte).toString(2);
                            var padLen = 8 - ascii.length;
                            for (i = 0; i < padLen; i++) ascii = "0" + ascii;

                            for (bit = 0; bit < 8; bit++) {
                                entradaTabela = document.getElementById('checksumInputByte' + (byte+1) + 'Bit' + bit);
                                entradaTabela.innerHTML = ascii.charAt(bit);
                            }

                        }
                    }

                    function exemploChecksum(input) {

                        var saida = document.getElementById('exemploChecksumSaida');
                        var entrada = document.getElementById('exemploChecksumEntrada');
                        var s = entrada.value;
                        var i;
                        var sum = 0;
                        var par = 0;

                        exemploChecksumPreencheTabelaEntrada(s);

                        for (i = 0; i < s.length; i += 2) {

                            if (i + 1 < s.length)
                                par = (s.charCodeAt(i + 1) << 8);
                            par += s.charCodeAt(i);
                            sum += par;

                            if (i > 0) {

                                exemploChecksumPreencheTabelaParcelaCarry(i / 2 - 1, sum);
                            }

                            if (sum >= 65536)
                                sum -= 65535

                            if (i > 0) {

                                exemploChecksumPreencheTabelaParcelaSemCarry(i / 2 - 1, sum);
                            }

                        }

                        sum = 65535 - sum;
                        exemploChecksumPreencheTabelaFinal(sum);
                        saida.value = ('0000' + sum.toString(16)).slice(-4);
                    }
                </script>
            <ul>
                <li>Experimente o cálculo do <i>checksum</i> de algumas mensagens (<i>strings</i>):</li>
            </ul>
            <center>
            <div style="width: 60%; border: 2px solid #000; padding-bottom: 10px;">
            <table class="align" style="width: 90%;">
                <tr>
                    <td style="width: 90%;">Mensagem</td>
                    <td><input type="text" id="exemploChecksumEntrada" name="exemploChecksumEntrada" value="RedesI" size="10" maxlength="10" style="font-size: 80%; padding: 0.5%;"/></td>
                </tr>
                <tr>
                    <td>Checksum</td>
                    <td><input type="text" readonly="true" id="exemploChecksumSaida" name="exemploChecksumSaida" value="ebd5" size="10" maxlength="4" style="font-size: 80%; padding: 0.5%;" /></td>
                </tr>
            </table>
            <br>
            <input type="submit" name="exemploChecksumCalcular" value="Calcular" style="padding: 0.5%; font-size: 90%; font-family: 'Lora', sans-serif;" onClick="exemploChecksum();"/>
            <br>
            </div>
            </center>
            <ul>
                <li>Sugestão: calcule o <i>checksum</i> de &ldquo;casa&rdquo;.
                <ul>
                    <li>Resultado: 0x3d29.</li>
                    <li>Em ASCII: 0x3D &#8594; &ldquo;=&rdquo;.</li>
                    <li>Em ASCII: 0x29 &#8594; &ldquo;)&rdquo;.</li>
                </ul></li>
                <li><span class="alert">Pergunta:</span> qual é o <i>checksum</i> de &ldquo;casa)=&rdquo;?</li>
            </ul>
        </div>
        <div class="column" style="width: 50%;">
            <div style="width: 100%; height: 450px;">
                <table class="align" id="exemploChecksumInputBits">
                </table>
            </div>
        </div>
    </div>
    </section>

    <!-- {{{{ dzslides core
	#
	#
	#     __  __  __       .  __   ___  __
	#    |  \  / /__` |    | |  \ |__  /__`
	#    |__/ /_ .__/ |___ | |__/ |___ .__/ core :€
	#
	#
	# The following block of code is not supposed to be edited.
	# But if you want to change the behavior of these slides,
	# feel free to hack it!
	#
	-->

    <!-- More CSS -->
	<link href='../template/css/slides.css' id="slides" rel='stylesheet' type='text/css'>
	<link href='../template/css/presentationSpecific2.css' id="presentationSpecific2" rel='stylesheet' type='text/css'>

    <!-- More Javascript -->
	<script type="text/javascript" src="../template/js/dz.js"></script>

	<!-- More CSS -->
	<link href='../template/css/notesSpecific.css' id="notesSpecific" rel='stylesheet' type='text/css'>
	<link href='../template/css/printSpecific.css' id="printSpecific" rel='stylesheet' type='text/css'>
</body>
</html>
