<!DOCTYPE html>
<html>
  <head>
    <title>Apresentação de Artigo: XORs in the Air: Practical Wireless Network Coding</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../template/css/roboto.css">
    <link rel="stylesheet" type="text/css" href="../template/css/general.css">
    <link rel="stylesheet" type="text/css" href="../template/css/code.css">
    <link rel="stylesheet" type="text/css" href="../template/css/cover.css">
    <link rel="stylesheet" type="text/css" href="../template/css/section.css">
    <link rel="stylesheet" type="text/css" href="../template/css/elements.css">
    <link rel="stylesheet" type="text/css" href="../template/css/table.css">
    <link rel="stylesheet" type="text/css" href="../template/css/block.css">
    <link rel="stylesheet" type="text/css" href="../template/css/dagre.css">
    <style>
      span.katex {
        font-size: 0.95em;
      }
    </style>
  </head>
  <body>

    <textarea id="source">


class: cover-slide

![:cover](
Computação Móvel
Apresentação do Artigo<br><i>XORs in the Air: Practical Wireless Network Coding</i>
Diego Passos
../template/img/logo.svg
)

---

class: middle
layout: true
name: conteudo

.title[
{{slideTitle}}
<hr>]

---

slideTitle: Dados Bibliográficos

#### Autores
* Sachin Katti, Hariharan Rahul, Dina Katabi, Muriel Médard e Jon Crowcroft.
	* MIT.
* Wenjun Hu.
	* University of Washington,

#### Periódico
* *IEEE/ACM Transactions on Networking*

#### Ano
* 2008.

---

layout: false
class: section-slide

# Introdução

---

class: middle
layout: true
name: conteudo

.title[
{{slideTitle}}
<hr>]

---

slideTitle: Conteúdo do Artigo


![:block](COPE
* Uma "arquitetura" para redes em malha sem fio.
* Além de encaminhados, os pacotes são combinados.
* *Network Coding*.

)
![:block](Avaliação de Desempenho
* Feita em uma rede real de 20 nós.
* Mostra melhoras consideráveis.
	* De 3 a 4 vezes melhor para UDP.
	* De 5% a 70% para TCP.
)

---

slideTitle: Redes em Malha Sem Fio (*Mesh*)


.center[
![:image 60%](imagens/meshCinza.png)
]

![:block](Características
* Comunicação em múltiplos saltos.
* Variação da qualidade dos enlaces no tempo.
* Auto-configuração e tolerância a falhas.

)

---

slideTitle: *Network Coding*

	
#### Definição
* É o ato de nós intermediários combinarem informações de vários canais de entrada em uma única unidade de informação para um canal de saída.
* Objetiva-se aumentar robustez ou capacidade da rede.
* Cada nó da rede pode ser visto como uma matriz de transformação (linear ou não) dos diversos pacotes sendo gerados na rede.
* Para decodificar um pacote, o nó de destino deve aplicar a matriz de transformação inversa.


---

slideTitle: *Network Coding* (Exemplo)


.center[
![:image 50%](imagens/CodingExemplo.png)
]

* Suponha uma transmissão de dois bits de $1$ para $6$ e $7$.
* Solução com *Network Coding*:
	* Transmitir $b_1$ por $1\rightarrow 2$, $2\rightarrow 4$ e $2\rightarrow 6$.
	* Transmitir $b_2$ por $1\rightarrow 3$, $3\rightarrow 4$ e $3\rightarrow 7$.
	* Transmitir $b_1 \oplus b_2$ por $4\rightarrow 5$, $5\rightarrow 6$ e $5\rightarrow 7$.

---

slideTitle: *Network Coding*: Características


* Permite atingir o limite teórico de fluxo máximo (teorema do Fluxo Máximo - Corte Mínimo).
* Permite a redução do número total de transmissões
	* Ótimo em redes sem fio de múltiplos saltos.
* Implementação prática não é trivial.
	* Na prática, as topologias não são tão "controladas".
	* Em redes sem fio, as topologias podem mudar dinamicamente.
	* Como escolher um esquema de codificação eficiente neste caso?

---

layout: false
class: section-slide

# COPE

---

class: middle
layout: true
name: conteudo

.title[
{{slideTitle}}
<hr>]

---

slideTitle: Características


* Esquema genérico de codificação.
* Pode ser aplicado a qualquer topologia.
* Se adapta automaticamente a mudanças.
* Não faz suposições sobre a característica dos fluxos.
* Provê codificação inter-fluxos.
* A codificação/decodificação é feita salto a salto.
	* Foge um pouco ao conceito original de codificação de rede.

---

slideTitle: Implementação


* Uma nova camada é adicionada entre o roteamento e o enlace.
* Tenta detectar oportunidades de codificação.
	* Caso existam, os pacotes são combinados via XOR.
	* Caso contrário, eles são enviados normalmente.
* Divide-se em 3 funcionalidades:
	* Codificação oportunista.
	* Escuta oportunista.
	* Aprendizado do estado dos vizinhos.

---

slideTitle: Codificação Oportunista


![:block](Objetivos
* Maximizar o número de pacotes entregues em cada transmissão.
* Garantir que os receptores sejam capazes de decodificar o pacote.

)

.center[
![:image 100%](imagens/OportunisticCodingEx.PNG)
]


---

slideTitle: Escuta Oportunista


![:block](Premissas
* O meio sem fio tem natureza compartilhada (difusão\).
* Nós, em geral, são equipados com antenas omni-direcionais.
)

![:block](Como tirar proveito?
* Nós são colocados em *modo promiscuo*.
* Todos os quadros transmitidos por vizinhos são recebidos (idealmente\).
* Todos os quadros são armazenados por um pequeno período de tempo ($0,5$s\).
	* Eles podem ser úteis para codificações posteriores.


)

---

slideTitle: Aprendizado do Estado dos Vizinhos


![:block](Objetivo
* Descobrir quais pacotes cada vizinho tem.

)

![:block](Solução
* Envio de anúncios periódicos por cada nó.
* Utilização de informação da camada de roteamento.
	* O protocolo de roteamento calcula a probabilidade de recepção de cada nó.
* Utiliza esta informação para estimar se um vizinho tem ou não um dado pacote.
* Por ser probabilística, a estratégia pode falhar.

)

---

layout: false
class: section-slide

# Ganhos Teóricos

---

class: middle
layout: true
name: conteudo

.title[
{{slideTitle}}
<hr>]

---

slideTitle: Tipos de Ganho


![:block](Ganho de Codificação
* Razão entre o número de transmissões necessárias sem o COPE pelo número com o COPE.
* Sempre maior ou igual a $1$.
* Sem a escuta oportunista, o limite teórico é $2$.

)

![:block](Ganho de Codificação + MAC
* Razão da taxa na qual pacotes saem da fila do nó de gargalo com e sem o COPE.

)

---

slideTitle: Exemplo: Topologia em Linha


.center[
![:image 75%](imagens/ChainTopology.PNG)
]

* Ganho de Codificação: $2$.
* Ganho de Codificação + MAC: 2.


---

slideTitle: Exemplo: Topologia em X


.center[
![:image 50%](imagens/Xtopology.PNG)
]

* Ganho de Codificação: $1,33$.
* Ganho de Codificação + MAC: 2.


---

slideTitle: Exemplo: Topologia em Cruz


.center[
![:image 50%](imagens/crossTopology.PNG)
]

* Ganho de Codificação: $1,6$.
* Ganho de Codificação + MAC: 4.




---

slideTitle: Exemplo: Topologia em Roda


.center[
![:image 60%](imagens/wheel.PNG)
]

* Ganho de Codificação: $2$.
* Ganho de Codificação + MAC: $\infty$ (não limitado).

---

layout: false
class: section-slide

# Detalhes de Implementação

---

class: middle
layout: true
name: conteudo

.title[
{{slideTitle}}
<hr>]

---

slideTitle: Algoritmo de Codificação


![:block](Características
* Pacotes não são atrasados.
	* Se não há oportunidade de codificação, os pacotes são enviados normalmente.
* Dá preferencia à codificação de pacotes de tamanho semelhante.
	* No entanto, isso não é regra.
* São criadas duas classes: pacotes grandes e pequenos (menos de 100 bytes\).
* Nunca serão codificados juntos:
	* Pacotes destinados ao mesmo próximo salto.
	* Pacotes gerados no próprio nó.


)

---

slideTitle: Algoritmo de Codificação (Cont.)


![:block](Busca por Pacotes
* São mantidas filas virtuais por vizinho.
	* Duas para cada.
* O primeiro pacote da fila real é escolhido.
* As filas virtuais são percorridas, buscando oportunidades de codificação.
	* Primeiro às de tamanho semelhante, depois de tamanho diferente.


)

![:block](Probabilidade de Decodificação
* Para $n$ pacotes codificados:
	$$P\_D = P\_1 \times P\_2 \times ... \times P\_{n-1}$$
)

---

slideTitle: Algoritmo de Codificação


.center[
![:image 60%](imagens/AlgCodificacao.PNG)
]


---

slideTitle: Pseudo-Broadcast


![:block](Motivação
* Pacotes precisam ser transmitidos para vários vizinhos.
* Nós precisam confirmar o recebimento.

)

![:block](Solução Proposta
* O quadro é enviado para um dos vizinhos em *unicast*.
* Os demais nós recebem o pacote de forma promiscua.
* A lista completa de receptores é colocada no cabeçalho do quadro.
* *Pseudo-broadcast* é mais confiável que *broadcast*.

)


---

slideTitle: *Hop-By-Hop Acks*


![:block](Motivação
* Pacotes codificados podem não ser recebidos por todos os nós.
* Mesmo quando recebidos, os nós podem não ser capazes de decodificá-los.

)

![:block](Solução Proposta
* Incorporar Acks nos pacotes periódicos de anúncio de pacotes disponíveis.
* O *overhead* de enviar um ack individualmente é muito alto.

)

---

slideTitle: Evitando Reordenação


![:block](Motivação
* Acks assíncronos podem causar reordenação de segmentos TCP.
* O TCP pode interpretar segmentos fora de ordem como congestionamento.
* Reduz o desempenho.

)

![:block](Solução Proposta
* Para os pacotes TCP destinados ao nó atual, o COPE verifica a ordem.
* Pacotes só são entregues para a camada superior se não houver ``buracos''.
	* Ou até um *timer* expirar.


)

---

slideTitle: Formato do Pacote


.center[
![:image 80%](imagens/PktFormat.PNG)
]


---

layout: false
class: section-slide

# Avaliação

---

class: middle
layout: true
name: conteudo

.title[
{{slideTitle}}
<hr>]

---

slideTitle: Ambiente de Testes


![:block](Características
* $20$ nós em dois andares de um prédio.
* Número de saltos varia de $1$ a $6$.
* Taxa de perda entre $0\%$ e $30\%$.
* 802.11a .
* $6$Mb/s.

)

![:block](*Software*
* Click.
* Fila de $100$ pacotes.
* Srcr com métrica ETT.
* Libpcap.

)

---

slideTitle: Ambiente de Testes (Cont.)


![:block](*Hardware*
* PCs.
* Duas interfaces de rede.
	* Só uma é usada.
* RTS/CTS desabilitado.

)

![:block](Modelo de Tráfego
* Fluxos UDP (udpgen\).
* Fluxos TCP (ttcp\).
	* Longos ou curtos.


)

---

slideTitle: TCP: Topologias Simples (I)

.center[
![:image 60%](imagens/GainAliceBobTCP.PNG)
<br>
**(a) Alice-and-Bob}**
![:image 60%](imagens/GainXtopologyTCP.PNG)
<br>
**(b) Topologia em X**
]

---

slideTitle: TCP: Topologias Simples (II)

.center[
![:image 60%](imagens/GainCrosstopologyTCP.PNG)
<br>
**(c) Topologia em cruz**
]

---

slideTitle: UDP: Topologias Simples (I)

.center[
![:image 60%](imagens/GainAliceBobUDP.PNG)
<br>
**(a) Alice-and-Bob**
![:image 60%](imagens/GainXtopologyUDP.PNG)
<br>
**(b) Topologia em X**
]

---

slideTitle: UDP: Topologias Simples (II)

.center[
![:image 60%](imagens/GainCrosstopologyUDP.PNG)
<br>
**(c) Topologia em cruz**
]

---

slideTitle: Efeitos das Colisões

	
.center[
![:image 60%](imagens/LossFrac.png)
![:image 60%](imagens/QueueSize.png)
]
	

---

slideTitle: TCP sem Terminais Escondidos


.center[
![:image 85%](imagens/TCPNoHidden.PNG)
]

---

slideTitle: UDP no Cenário em Larga Escala


.center[
![:image 85%](imagens/UDPLarge.PNG)
]

---

slideTitle: Resultados Sobre a Codificação


.center[
![:image 70%](imagens/GuessCoding.PNG)
![:image 70%](imagens/CodingDist.PNG)
]


---

slideTitle: TCP em Rede de Acesso


.center[
![:image 95%](imagens/TCPRedeAcesso.PNG)
]

---

slideTitle: Justiça


.center[
![:image 55%](imagens/JusticaVazao.PNG)
![:image 55%](imagens/Justica.PNG)
]


---

layout: false
class: section-slide

# Conclusão

---

class: middle
layout: true
name: conteudo

.title[
{{slideTitle}}
<hr>]

---

slideTitle: Considerações Finais


![:block](Aplicabilidade
* Dispositivos sem restrições de recursos.
* Grande capacidade de memória.
* Antenas omni-direcionais.
* Sem restrições de energia.

)

![:block](Outros Tipos de Rede
* Outros protocolos de camada de enlace.
	* WiMax.
	* TDMA.
* Redes de sensores.
	* Menos transmissões, menor gasto energético.
* Celular.
	* Menores custos.


)

</template>
</textarea>

<script src="../template/js/remark-latest.min.js" type="text/javascript"></script>
<script src="../template/js/d3.v4.js"></script>
<script src="../template/js/graphlib-dot.js"></script>
<script src="../template/js/dagre-d3.min.js"></script>
<script src="../template/js/dagre-d3-extra.js"></script>
<script src="../template/js/macros.js" type="text/javascript"></script>
<script src="../template/js/callbacks.js" type="text/javascript"></script>
<script src="../template/js/katex.min.js"></script>
<script src="../template/js/auto-render.min.js"></script>
<link rel="stylesheet" href="../template/css/katex.min.css">
<script type="text/javascript">

	var renderMath = function() {
		renderMathInElement(document.body, {delimiters: [
			 {left: "$$", right: "$$", display: true},
			 {left: "$", right: "$", display: false},
		]});
	}

	var slideshow = remark.create({highlightStyle: "github", highlightLines: "true", highlightSpans: "true", slideNumberFormat: onSlideCallback}, renderMath);

	dagreRenderAllSlides();

</script>
</body>
</html>
