<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Transmissão Confiável de Dados no TCP</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Transmissão Confiável de Dados no TCP</h1>
</header>
<p>Embora o TCP forneça também outros serviços importantes, como o controle de fluxo e o controle de congestionamento, talvez sua característica mais notável seja a confiabilidade na entrega dos dados. Nessas notas de aula, veremos quais são e como o TCP implementa seus mecanismos de confiabilidade.</p>
<h2 id="escolhendo-valores-para-o-temporizador">Escolhendo Valores para o Temporizador</h2>
<p>Como visto em aulas anteriores, temporizadores (ou <em>timers</em>) são mecanismos fundamentais para a implementação de um protocolo de transmissão confiável de dados sobre um canal/rede não confiável. Em particular, temporizadores auxiliam este tipo de protocolo a lidar com a possibilidade de <em>supressão de pacotes</em>, <em>i.e.</em>, que pacotes sejam perdidos/descartados pela rede: eles provêm um sinal independente da rede que impede que o protocolo (em particular, o transmissor) fique travado aguardando um evento de recepção de pacotes pela rede.</p>
<p>Por este motivo, assim como protocolos estudados em aulas anteriores, o TCP também emprega temporizadores. Quando o temporizador expira, o TCP interpreta este evento como um indicativo de perda de pacotes e realiza a retransmissão de segmentos. Uma questão importante que não foi discutida até aqui, no entanto, diz respeito ao valor inicial do temporizador: <em>i.e.</em>, quanto tempo devemos esperar até supormos que um segmento foi perdido e, portanto, deve ser retransmitido?</p>
<p>A resposta para esta pergunta varia bastante. Claramente, o valor deste temporizador deve ser suficientemente grande para que o segmento saia do transmissor, chegue ao receptor e o <em>ack</em> correspondente volte ao transmissor. Em outras palavras, o temporizador deve ser ao menos tão longo quanto o RTT (<em>Round Trip Time</em>) entre transmissor e receptor. Do contrário, o temporizador sempre expirará de forma prematura, resultando na retransmissão de segmentos que não foram, de fato, perdidos. Por outro lado, um valor excessivamente alto tornará a detecção de perdas muito lenta, atrasando o processo de retransmissão e afetando negativamente o desempenho do protocolo.</p>
<p>Desta forma, para que o TCP escolha um valor adequado para o temporizador, é fundamental que ele conheça o RTT do caminho entre transmissor e receptor. Para isso, o TCP realiza amostras do RTT com base nos tempos de transmissão dos segmentos de dados e de recepção dos respectivos <em>acks</em>: toda vez que um segmento de dados é transmitido, o TCP armazena o horário atual; ao receber <strong>o primeiro</strong> <em>ack</em> relativo a este segmento de dados, o TCP subtrai os dois tempos, obtendo uma nova amostra do RTT. Daqui para frente, chamaremos esta amostra de <code>SampleRTT</code>.</p>
<p>Por diversos motivos, o <code>SampleRTT</code> de um segmento tende a ser diferente daquele de segmentos subsequentes. Um dos principais fatores é a simples variação dos níveis de congestionamento nos roteadores intermediários, o que, em última análise, causa variação nos atrasos de enfileiramento, culminando na variação do RTT como um todo. Por isso, se utilizássemos diretamente os valores de <code>SampleRTT</code> como o valor inicial dos temporizadores, estaríamos susceptíveis a variações muito bruscas. Com o objetivo de suavizar esta variabilidade, o TCP baseia sua estimativa do RTT não em uma única amostra, mas sim em uma <strong>média de amostras anteriores</strong>.</p>
<p>Embora a ideia de computar o RTT médio em uma janela das <span class="math inline">\(n\)</span> últimas amostras pareça simples, do ponto de vista de implementação uma preocupação é o tamanho desta janela. Em um dispositivo embarcado, por exemplo, com baixa capacidade computacional, talvez seja indesejável manter uma grande quantidade de amostras em memória <strong>para cada conexão TCP</strong>. Uma solução de menor complexidade computacional (particularmente, em termos de armazenamento) é o uso de uma <em>Média Móvel Exponencialmente Ponderada</em>.</p>
<p>Este tipo de média é definido por uma simples relação de recorrência: <span class="math display">\[\label{eq:estimativaRTT}
    \text{EstimatedRTT} = (1-\alpha)\times\text{EstimatedRTT} + \alpha\times\text{SampleRTT},\]</span> onde <span class="math inline">\(0 &lt; \alpha &lt; 1\)</span> é um parâmetro ajustável</p>
<p>Cada vez que um novo <code>SampleRTT</code> é coletado pelo TCP, a Equação é computada novamente, utilizando-se o valor anterior da média (<em>i.e.</em>, <code>EstimatedRTT</code>) e a amostra atual (<em>i.e.</em>, <code>SampleRTT</code>). Nota-se, portanto, que é suficiente que o TCP armazene apenas o resultado da última aplicação da Equação, sem a necessidade de manter um histórico potencialmente longo dos últimas amostras.</p>
<p>Repare o que acontece se aplicarmos sucessivamente a Equação a um conjunto de amostras (índices foram incluídos para permitir distinguir entre as várias amostras):</p>
<p><span class="math display">\[\begin{aligned}
  \text{EstimatedRTT}_{t} &amp; = (1-\alpha)\times\text{EstimatedRTT}_{t-1}\nonumber\\
  &amp; + \alpha\times\text{SampleRTT}_{t}\end{aligned}\]</span> <span class="math display">\[\begin{aligned}
  \text{EstimatedRTT}_{t} &amp; = (1 - \alpha)^2\times\text{EstimatedRTT}_{t-2}\nonumber\\
  &amp; + (1 - \alpha)\times\alpha\times\text{SampleRTT}_{t-1}\nonumber\\
  &amp; + \alpha\times\text{SampleRTT}_{t}\end{aligned}\]</span> <span class="math display">\[\begin{aligned}
  \text{EstimatedRTT}_{t} &amp; = (1 - \alpha)^3\times\text{EstimatedRTT}_{t-3}\nonumber\\
  &amp; + (1 - \alpha)^2\times\alpha\times\text{SampleRTT}_{t-2}\nonumber\\
  &amp; + (1 - \alpha)\times\alpha\times\text{SampleRTT}_{t-1}\nonumber\\
  &amp; + \alpha\times\text{SampleRTT}_{t}\\
  &amp; \dots\nonumber\end{aligned}\]</span></p>
<p>À medida que as amostras se sucedem, as amostras mais antigas são progressivamente multiplicadas por potências crescentes de <span class="math inline">\((1-\alpha)\)</span>. Como <span class="math inline">\(0 &lt; (1-\alpha) &lt; 1\)</span>, quanto mais alto o expoente, menor o valor da potência. Em suma, o que acontece é que amostras mais antigas recebem pesos cada vez menores. Este comportamento — de “esquecer” o passado antigo — é o desejável, já que a situação da rede pode mudar durante o tempo de vida de uma conexão.</p>
<p>A Figura <a href="#fig:EstimativaRTT" data-reference-type="ref" data-reference="fig:EstimativaRTT">1</a> ilustra o efeito da aplicação desta média móvel a uma sequência de amostras de RTT para um trecho de uma conexão TCP real. No gráfico, a curva vermelha ilustra a sequência de valores de <code>SampleRTT</code> medidos pelo TCP, enquanto a curva verde mostra a evolução da média móvel. Embora a curva verde também apresente variabilidade, repare como esta é menor que a variabilidade de curva vermelha.</p>
<figure>
<img src="imagens/EstimativaRTT.svg" alt="Figura 1: Séries temporais ilustrando as evoluções das amostras de RTT (SampleRTT), da estimativa baseada em uma Média Móvel Exponencialmente Ponderada (EstimatedRTT) e o valor do timeout resultante para um trace de uma conexão TCP real. Repare como o RTT amostral oscila em torno do RTT estimado (i.e., médio), enquanto a soma dos desvios provê uma margem de segurança geralmente capaz de absorver variações pontuais." id="fig:EstimativaRTT" /><figcaption>Figura 1: Séries temporais ilustrando as evoluções das amostras de RTT (<code>SampleRTT</code>), da estimativa baseada em uma Média Móvel Exponencialmente Ponderada (<code>EstimatedRTT</code>) e o valor do <em>timeout</em> resultante para um <em>trace</em> de uma conexão TCP real. Repare como o RTT amostral oscila em torno do RTT estimado (<em>i.e.</em>, médio), enquanto a soma dos desvios provê uma margem de segurança geralmente capaz de absorver variações pontuais.</figcaption>
</figure>
<p>Outra observação que pode ser feita sobre o gráfico da Figura <a href="#fig:EstimativaRTT" data-reference-type="ref" data-reference="fig:EstimativaRTT">1</a> é que os valores das amostras de RTT oscilam em torno dos valores da média móvel. Embora isso seja o comportamento esperado, esta característica faz com que o uso direto do <code>EstimatedRTT</code> como valor para o temporizador seja uma má escolha, já que uma grande fração de segmentos experimentará um RTT superior à media, causando retransmissões desnecessárias.</p>
<p>A solução adotada pelo TCP é configurar o valor do temporizador para o <code>EstimatedRTT</code> <strong>acrescido de uma margem de segurança</strong>, capaz de absorver (ao menos em grande parte) as instâncias em que o RTT amostrado supera a média. Para determinar esta margem, o TCP mantém uma estimativa para um segundo parâmetro relacionado ao RTT: o <strong>desvio das amostras em relação à média</strong>, que daqui para frente será denotado por <code>DevRTT</code>. A cada nova amostra de RTT obtida, o TCP utiliza a seguinte equação para atualizar sua estimativa deste desvio:</p>
<p><span class="math display">\[\label{eq:estimativaDesvio}
\text{DevRTT} = (1-\beta)\times\text{DevRTT} + \beta\times\| \text{SampleRTT} - \text{EstimatedRTT}\|,\]</span> onde <span class="math inline">\(\beta\)</span> é um fator de ponderação configurável.</p>
<p>Pode-se notar que a essa equação é muito similar à usada para estimar o RTT. Em outras palavras, <code>DevRTT</code> é simplesmente uma Média Móvel Exponencialmente Ponderada das diferenças — em valor absoluto — entre as amostras de RTT e os respectivos valores de <code>EstimatedRTT</code>.</p>
<p>De posse dos valores atuais de <code>EstimatedRTT</code> e <code>DevRTT</code>, o TCP finalmente calcula o valor do temporizador — denotado deste ponto em diante por <code>TimeoutInterval</code> — segundo a seguinte equação: <span class="math display">\[\label{eq:valorTimeout}
\text{TimeoutInterval} = \text{EstimatedRTT} + 4\times\text{DevRTT}.\]</span></p>
<p>O termo <span class="math inline">\(4\times\text{DevRTT}\)</span> é, portanto, a margem de segurança à qual nos referimos anteriormente. Votando à Figura 1, podemos ver esta margem de segurança em ação. A curva azul ilustra a evolução do <code>TimeoutInterval</code> calculado com base nas amostras de RTT da conexão. Mesmo com a variabilidade dos valores de RTT experimentados pelos segmentos, durante o trecho representado na figura a curva azul se manteve sempre superior à curva vermelha (<em>i.e.</em>, das amostras). Isso significa que durante este trecho o TCP nunca inferiu erroneamente uma perda de segmento devido a um <strong>estouro prematuro do temporizador</strong>.</p>
<h2 id="transmissão-confiável-de-dados-no-tcp">Transmissão Confiável de Dados no TCP</h2>
<p>Neste ponto, já introduzimos as características gerais de cada um dos mecanismos empregados pelo TCP para garantir a transmissão confiável de dados, a saber: temporizadores, números de sequência, <em>acks</em> e <em>pipeline</em>. Nesta seção, discutiremos como o TCP junta todos estes mecanismos em uma solução unificada para garantir a confiabilidade na transmissão dos dados.</p>
<p>Como discutido em aulas anteriores, os <em>acks</em> do TCP são cumulativos, <em>i.e.</em>, eles reconhecem todos os dados enviados até um determinado número de sequência. Em particular, o número de sequência informado em um <em>ack</em> diz respeito ao <strong>próximo byte esperado</strong> pelo receptor<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>Em relação aos temporizadores, o TCP mantém apenas um, sempre associado ao segmento em trânsito mais antigo — ou, dito de outra forma, o segmento que está na base da janela do transmissor.</p>
<p>Ao contrário de outros protocolos simplificados com os quais trabalhamos até agora (como o <em>Go-Back-N</em> e a <em>Repetição Seletiva</em>), o TCP utiliza dois mecanismos para inferir perdas de segmentos: o estouro de temporizador (assim como os protocolos estudados anteriormente) e <strong>a ocorrência de <em>acks</em> repetidos</strong>. Este último mecanismo é uma otimização denominada <em>Fast Retransmit</em>, a qual será estudada em detalhes mais à frente.</p>
<p>Supondo que um transmissor TCP não receba <em>acks</em> repetidos, há três eventos principais que concernem a transmissão confiável de dados:</p>
<ol class="incremental" type="1">
<li><p><strong>Recebimento de novos dados da aplicação</strong>. Assumindo que haja espaço suficiente na janela do transmissor — <em>i.e.</em>, números de sequência disponíveis — o TCP aceita os dados, os encapsula em um novo segmento com o próximo número de sequência disponível e realiza a transmissão. Se não há um temporizador ativo neste momento, o TCP inicia um associado ao segmento recém-transmitido. O valor inicial deste temporizador é dado pelo valor atual da variável <code>TimeoutInterval</code>, conforme discutido na seção anterior.</p></li>
<li><p><strong>Estouro de temporizador</strong>. Neste caso, o TCP realiza a retransmissão do segmento <strong>associado ao temporizador</strong> — ou seja, sempre do segmento mais antigo em trânsito (ou colocando de outra forma: sempre do segmento na base da janela do transmissor). Note que, com a retransmissão do segmento, este continua com <em>ack</em> pendente e na base da janela. Logo, deve-se reiniciar o temporizador novamente associado ao segmento em questão.</p></li>
<li><p><strong>Recepção de um <em>ack</em></strong>. Lembre-se que, por enquanto, estamos assumindo que o transmissor nunca recebe <em>acks</em> repetidos. Isso significa que os <em>acks</em> sempre reconhecem segmentos que o transmissor atualmente considera como pendentes. Nesta situação, o transmissor marca todos os números de sequência menores que o valor informado no <em>ack</em> como reconhecidos e anda a janela até este mesmo valor. Como o temporizador está sempre associado ao segmento da base da janela, devemos pará-lo — afinal, este segmento acabou de ser reconhecido. Ao final deste processo, se ainda constarem segmentos em trânsito na janela, o temporizador deve ser reiniciado para qualquer que seja o valor atual de <code>TimeoutInterval</code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p></li>
</ol>
<figure>
<img src="imagens/RetransmissaoEx1.svg" alt="Figura 2: Exemplo de retransmissão disparada por estouro de temporizador." id="fig:RetransmissaoEx1" /><figcaption>Figura 2: Exemplo de retransmissão disparada por estouro de temporizador.</figcaption>
</figure>
<p>Vamos exemplificar a ocorrência destes eventos com algumas situações simples. Considere inicialmente o cenário mostrado na Figura 2. O <em>host</em> A envia um segmento de dados com número de sequência 16 e 15 bytes de carga útil. O segmento é corretamente recebido pelo <em>host</em> B, que gera um <em>ack</em> correspondente. Por algum motivo, o pacote que carrega este <em>ack</em> é perdido. O <em>host</em> A reage à ocorrência desta perda quando, mais tarde, seu temporizador expira. Como reação, o <em>host</em> A realiza a retransmissão do segmento mais antigo — neste caso, há apenas um segmento em trânsito. Quando o segmento retransmitido alcança o <em>host</em> B, este facilmente identifica que se trata de uma duplicata utilizando o número de sequência. De toda maneira, o <em>host</em> B gera um novo <em>ack</em> que finalmente é recebido com sucesso por A. Embora isso não seja ilustrado na figura, ao receber o <em>ack</em>, A irá marcar todos os números de sequência de 16 a 30 (inclusive) como reconhecidos, andará com sua janela — a nova base será agora o número de sequência 31 — e <strong>não</strong> reiniciará o temporizador, já que neste exemplo não há outros segmentos em trânsito neste momento.</p>
<p>Do ponto de vista da escolha do valor do temporizador, a situação ilustrada na Figura 2 representa um sucesso: a expiração do temporizador corretamente infere a ocorrência de uma perda de pacotes — embora, no exemplo, trata-se do <em>ack</em>, e não do segmento de dados. Infelizmente, este nem sempre é o caso. Algumas vezes o temporizador expirará de forma precoce, resultando em uma retransmissão desnecessária. Este cenário é exemplificado na Figura 3. Ao invés de transmitir um único segmento, o <em>host</em> A transmite dois segmentos em sequência — segmentos 16 (de 15 bytes) e 31 (de 20 bytes). Ambos os segmentos são recebidos com sucesso pelo <em>host</em> B, que gera dois <em>acks</em>. Ambos os <em>acks</em> são eventualmente recebidos com sucesso pelo <em>host</em> A, porém não antes da expiração do temporizador. Como no TCP o temporizador é sempre implicitamente associado ao segmento na base da janela do transmissor, sua expiração tem como consequência a retransmissão apenas do segmento de número de sequência 16. Logo em seguida, ao receber o <em>ack</em> 31, o <em>host</em> A marca todos os números de sequência até o 30 (inclusive) como reconhecidos. A base da sua janela de transmissão é deslocada até o próximo número de sequência não reconhecido — neste caso, o 31. Embora não mostrado na figura, o temporizador é interrompido (devido ao reconhecimento do segmento anteriormente na base da janela) e reiniciado (devido à existência de outros segmentos ainda em trânsito). Antes que este temporizador possa expirar, no entanto, o <em>ack</em> 51 é recebido, fazendo com que o <em>host</em> A marque todos os números de sequência até o 50 (inclusive) como recebidos, ande sua janela até o próximo número de sequência não reconhecido — neste ponto, o 51. Adicionalmente, o temporizador, até então associado ao segmento de número de sequência 31, é interrompido. Como não há mais segmentos em trânsito, não há necessidade de reiniciá-lo.</p>
<figure>
<img src="imagens/RetransmissaoEx2.svg" alt="Figura 3: Exemplo de retransmissão precoce disparada por estouro de temporizador." id="fig:RetransmissaoEx2" /><figcaption>Figura 3: Exemplo de retransmissão <strong>precoce</strong> disparada por estouro de temporizador.</figcaption>
</figure>
<p>Note que a retransmissão desnecessária do segmento 16 chega com sucesso no <em>host</em> B. Como se trata de uma duplicata — reconhecida através do número de sequência do segmento — o <em>host</em> B não entregará seu conteúdo à aplicação. No entanto, B ainda gera um <em>ack</em> como consequência. Assim como todo <em>ack</em> no TCP, o número de sequência informado é o do próximo byte esperado pelo receptor. Neste caso, por já ter recebido ambos os segmentos, 16 e 31, o <em>host</em> B gera um <em>ack</em> 51. Este <em>ack</em> é recebido corretamente pelo <em>host</em> A, mas não traz efeitos práticos, já que se trata de um <em>ack</em> duplicado</p>
<p>Como um último exemplo, considere a situação ilustrada na Figura 4. Neste caso, novamente o <em>host</em> A transmite dois segmentos em sequência – segmentos 16 e 31. Ambos chegam com sucesso ao <em>host</em> B, disparando a transmissão de dois <em>acks</em>: o <em>ack</em> 31, relativo ao segmento 16, e o <em>ack</em> 51, relativo ao segmento 31. Infelizmente, o primeiro <em>ack</em> é perdido, fazendo com que apenas o segundo chegue ao <em>host</em> A. Repare, no entanto, que como o TCP utiliza <em>acks</em> cumulativos, toda a semântica do primeiro <em>ack</em> é incluída no segundo: quando o <em>ack</em> 51 chega à A, este reconhece todos os números de sequência até o 50 (inclusive) — o que inclui os números de sequência 16, 17, …, 30, contidos no primeiro segmento. Isso faz com que o <em>host</em> A possa avançar sua janela de transmissão até o número de sequência 51 (próximo ainda não reconhecido) e parar seu temporizador, já que, neste ponto, não há outros segmentos em trânsito.</p>
<figure>
<img src="imagens/RetransmissaoEx3.svg" alt="Figura 4: Exemplo de um ack posterior suprimindo a perda de um ack anterior, graças ao uso de acks cumulativos pelo TCP." id="fig:RetransmissaoEx3" /><figcaption>Figura 4: Exemplo de um <em>ack</em> posterior suprimindo a perda de um <em>ack</em> anterior, graças ao uso de <em>acks</em> cumulativos pelo TCP.</figcaption>
</figure>
<h2 id="acks-atrasados">Acks Atrasados</h2>
<p>Até aqui temos assumido implicitamente que a recepção de um segmento — duplicado ou não — sempre resulta na geração imediata de um <em>ack</em> pelo receptor. Na verdade, as RFCs 1122 e 2581 definem que um receptor TCP pode, em certos casos, atrasar propositalmente a geração de um <em>ack</em> por <strong>até 500 ms</strong> ao receber um segmento de dados.</p>
<p>Há várias motivações para atrasar um <em>ack</em> no TCP, dentre as quais citaremos duas aqui:</p>
<ol class="incremental" type="1">
<li><p><strong>Suprimir um <em>ack</em></strong>. Como <em>acks</em> são cumulativos no TCP, ao receber múltiplos segmentos em sequência, um receptor poderia, em teoria, gerar um único <em>ack</em> — relativo ao último segmento — reconhecendo todos os pacotes recebidos. A vantagem, neste caso, está na economia de <em>overhead</em> de controle do protocolo: ao invés de enviar <span class="math inline">\(n\)</span> <em>acks</em> para reconhecer <span class="math inline">\(n\)</span> segmentos de dados, bastaria 1. Ao atrasar a geração do <em>ack</em> relativo a um segmento específico, um receptor possibilitaria a recepção de outros segmentos subsequentes, permitindo esta redução de <em>overhead</em>.</p></li>
<li><p><strong>Combinar <em>ack</em> e dados em um mesmo segmento</strong>. Como segmentos TCP podem combinar <em>ack</em> e dados — <em>i.e.</em>, um segmento pode, simultaneamente, servir de <em>ack</em> para um fluxo de bytes em um sentido <em>e</em> transportar dados do fluxo de bytes no sentido contrário —, ao receber um segmento de dados, um receptor pode atrasar a geração do respectivo <em>ack</em> para que, talvez, a aplicação local gere dados a serem enviados. Neste caso, um único segmento transportará tanto o <em>ack</em> quanto os dados, reduzindo o número de pacotes transmitidos durante a conexão.</p></li>
</ol>
<p>Embora o emprego de <em>acks</em> atrasados tenha o potencial de reduzir o número de segmentos enviados em uma conexão, ele também pode trazer efeitos indesejados. Um destes efeitos é relacionado ao temporizador do transmissor: o atraso artificial embutido pelo receptor na geração do <em>ack</em> torna mais provável a expiração do temporizador no transmissor, resultando em retransmissões desnecessárias — já que, por hipótese, o segmento foi recebido com sucesso. Há também um efeito negativo na estimativa do RTT — e, por consequência, na escolha dos valores dos temporizadores — já que este tempo artificial será refletido no <code>SampleRTT</code>.</p>
<p>Por conta disso, o uso de <em>acks</em> atrasados pelo TCP é restrito a um caso específico: quando o segmento é recebido em ordem (<em>i.e.</em>, tem exatamente o número de sequência esperado e não foram recebidos outros segmentos com número de sequência posteriores) e não há atualmente um <em>ack</em> sendo atrasado para algum dos segmentos anteriores. Em qualquer outro caso, a chegada de um segmento — novo ou repetido — deve resultar na geração imediata de um <em>ack</em>.</p>
<p>Em particular, repare que, ao atrasar o <em>ack</em> de um segmento, se um outro segmento — novo, em ordem ou não, ou repetido — chega durante o período de 500 ms, o receptor imediatamente gera um <em>ack</em>. Como sempre, o <em>ack</em> deve informar o próximo byte esperado pelo receptor.</p>
<h2 id="fast-retransmit">Fast Retransmit</h2>
<p>Na descrição realizada dos eventos básicos pertinentes à transmissão confiável de dados pelo TCP — do ponto de vista do transmissor — citamos o recebimento de <em>acks</em>, mas só nos preocupamos com o caso em que o <em>ack</em> efetivamente reconhece segmentos até então considerados pendentes. Embora o transmissor pudesse simplesmente ignorar <em>acks</em> repetidos ainda assim garantir a confiabilidade da comunicação, é possível utilizar a recepção de <em>acks</em> repetidos como uma oportunidade de otimização. É exatamente disso que trata o mecanismo de <em>Fast Retransmit</em>.</p>
<p>Para entender a motivação deste mecanismo, considere a situação ilustrada na Figura 5. Em certo momento, o <em>host</em> A transmite uma <strong>rajada</strong> (<em>i.e.</em>, uma sequência de pacotes transmitidos um após o outro, o mais rápido possível) de cinco segmentos. Quase todos são entregues com sucesso pela rede para o <em>host</em> B, exceto pelo segundo segmento da rajada, com número de sequência 31. Após o recebimento do primeiro pacote, o <em>host</em> B envia um <em>ack</em> reconhecendo o recebimento do segmento 16 — informado através de um <em>ack</em> 31, já que o segmento 16 tem 15 bytes de dados. Quando os segmentos subsequentes — 41, 52 e 57 — chegam ao <em>host</em> B, este ainda gera <em>acks</em>, mas todos são apenas repetições do <em>ack</em> 31 enviado anteriormente, já que os segmentos recebidos estão fora de ordem. No cenário hipotético ilustrado na figura, todos estes 4 <em>acks</em> chegam ao <em>host</em> A: o <em>ack</em> 31 original e mais três repetições (ou três <strong><em>acks</em> duplicados, no jargão do TCP</strong>).</p>
<figure>
<img src="imagens/FastRetransmitMotivacao.svg" alt="Figura 5: Cenário que motiva o emprego do Fast Retransmit." id="fig:FastRetransmitMotivacao" /><figcaption>Figura 5: Cenário que motiva o emprego do <em>Fast Retransmit</em>.</figcaption>
</figure>
<p>Considerando apenas os mecanismos descritos até aqui, o <em>host</em> A — transmissor, neste exemplo — deveria simplesmente ignorar estes <em>acks</em> duplicados. O eventual — e inevitável, neste caso — estouro do temporizador é suficiente para lidar com a perda do segmento 31. Quando o primeiro <em>ack</em> 31 alcança o <em>host</em> A, este marca todos os números de sequência até o 30 (inclusive) como reconhecidos, interrompe o temporizador e o reinicia porque ainda há segmentos em trânsito. A partir deste instante, começa a contar o tempo até que o <em>host</em> A infira que o segmento 31 foi perdido e realize sua retransmissão.</p>
<p>Note, no entanto, que o intervalo entre a ocorrência da perda e o estouro do respectivo temporizador é relativamente longo. Por outro lado, a perda do segmento 31 associada ao correto recebimento de segmentos subsequentes pelo <em>host</em> B criou um comportamento curioso: a recepção, pelo <em>host</em> A, de várias duplicadas do <em>ack</em> 31. Cada uma destas duplicatas indica que o <em>host</em> B recebeu algum segmento de dados, mas, repetidamente, o segmento <strong>não foi</strong> o de número de sequência 31.</p>
<p>Do ponto de vista do transmissor (que não possui uma visão global do que está ocorrendo com cada pacote da rede), a recepção destes vários pacotes duplicados pode significar algumas situações diferentes:</p>
<ol class="incremental" type="1">
<li><p><strong>Reordenação de pacotes</strong>. O segmento 31 pode simplesmente estar sendo encaminhado por um caminho mais longo que os segmentos posteriores, fazendo com que estes sejam recebidos antes que aquele.</p></li>
<li><p><strong>Perda de pacote</strong>. O segmento 31 pode ter sido efetivamente perdido.</p></li>
</ol>
<p>Da mesma maneira que o estouro de um temporizador não é uma prova definitiva de que o segmento correspondente foi perdido, a recepção de múltiplos <em>acks</em> duplicados também pode ser um falso-positivo nesta tentativa de identificar perdas. No entanto, à medida que mais e mais <em>acks</em> duplicados são recebidos, é cada vez mais provável que, de fato, o segmento repetidamente solicitado pelo receptor tenha sido perdido.</p>
<p>Com base neste raciocínio, o mecanismo <em>Fast Retransmit</em> especifica que ao receber 3 <em>acks</em> repetidos para um mesmo número de sequência, um transmissor deve realizar imediatamente a retransmissão do segmento correspondente.</p>
<figure>
<img src="imagens/FastRetransmitEx.svg" alt="Figura 6: Fast Retransmit em ação: retransmissão do segmento 31 é realizada antes do estouro do temporizador, motivada pela chegada do terceiro ack repetido solicitando este mesmo número de sequência." id="fig:FastRetransmitEx" /><figcaption>Figura 6: <em>Fast Retransmit</em> em ação: retransmissão do segmento 31 é realizada antes do estouro do temporizador, motivada pela chegada do terceiro <em>ack</em> repetido solicitando este mesmo número de sequência.</figcaption>
</figure>
<p>Aplicando-se o <em>Fast Retransmit</em> ao cenário da Figura 5, obtemos o comportamento ilustrado na Figura 6. Embora haja uma retransmissão do segmento 31 ocorrendo no final da linha do tempo mostrada na figura, esta retransmissão é disparada pela recepção do terceiro <em>ack</em> duplicado solicitando o número de sequência 31, e não pelo estouro do temporizador — o que ainda demoraria algum tempo.</p>
<p>Como o TCP costumeiramente envia vários segmentos em rajada, a recepção de <em>acks</em> duplicados tende a ocorrer bem antes do estouro do temporizador em caso de perda. O efeito obtido pelo <em>Fast Retransmit</em>, portanto, é o de acelerar a detecção de segmentos perdidos e sua consequente recuperação, colaborando para uma melhora de desempenho do TCP.</p>
<p>Por fim, volte a considerar o mecanismo de <em>acks</em> atrasados. A eficácia do <em>Fast Retransmit</em> está diretamente ligada à rapidez com que os <em>acks</em> duplicados voltam do receptor para o transmissor. Se a possibilidade de atrasar <em>acks</em> fosse estendida a pacotes recebidos foram de ordem, por exemplo, o receptor estaria influenciando negativamente a capacidade do transmissor de detectar rapidamente perdas de segmentos.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Lembre-se que os números de sequência no TCP são contados em bytes, e não em pacotes.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Repare, portanto, que o tempo desde a transmissão inicial de um segmento até o sua retransmissão por estouro do temporizador pode ser maior que o valor de <code>TimeoutInterval</code>, já que o temporizador pode ser iniciado quando o segmento já foi transmitido há algum tempo.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
