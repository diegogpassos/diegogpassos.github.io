<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Roteamento Multicast</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Roteamento Multicast</h1>
</header>
<p>Em uma comunicação <em>multicast</em>, mensagens são destinadas a um <strong>sub-conjunto dos nós de uma rede.</strong> Este sub-conjunto é geralmente próprio — <em>i.e.</em>, não inclui todos os nós da rede — já que, do contrário, a comunicação seria <em>broadcast</em>. Este conjunto de nós aos quais a mensagem <em>multicast</em> interessa recebe o nome de um <strong>grupo <em>multicast</em></strong>. O problema de roteamento <em>multicast</em>, portanto, consiste em encontrar uma árvore — ou várias — que interconecta todos os membros do grupo <em>multicast</em>.</p>
<p>Note que uma árvore geradora atende a este requisito: é uma árvore que interconecta todos os nós da rede — e, portanto, todos os membros do grupo <em>multicast</em>, qualquer que seja este grupo. Entretanto, é comum que existam árvores muito menores que uma árvore geradora — <em>i.e.</em>, que envolvam menos nós da rede — que ainda interconectem todos os nós do grupo <em>multicast</em>. Desta forma, ao contrário de uma árvore geradora, uma <strong>árvore <em>multicast</em></strong> geralmente contém apenas um sub-conjunto (potencialmente pequeno) do total de nós da rede. É importante ressaltar, no entanto, que normalmente não é possível interconectar todos os membros de um grupo <em>multicast</em> sem utilizar alguns outros nós que não fazem parte do grupo. Logo, as árvores <em>multicast</em> contêm todos os nós membros e, potencialmente, alguns nós não membros.</p>
<p>As abordagens para roteamento <em>multicast</em> podem ser divididas em duas famílias: as baseadas em <strong>árvore compartilhada</strong> e as baseadas em <strong>árvores enraizadas na fonte</strong>. Na primeira família, uma única árvore é definida sobre a rede, sendo utilizada para o encaminhamento independentemente da origem de cada pacote. Já na segunda, existirão múltiplas árvores potencialmente diferentes, cada uma utilizada para o encaminhamento de pacotes originados em cada membro do grupo <em>multicast</em>.</p>
<h2 id="soluções-baseadas-em-árvores-enraizadas-na-fonte">Soluções Baseadas em Árvores Enraizadas na Fonte</h2>
<p>Nesta família de soluções, uma primeira abordagem é a utilização da chamada <em>árvore de caminhos mais curtos</em>. Em um protocolo baseado em estado de enlaces, quando o algoritmo de Dijkstra é executado, o nó que efetua a execução descobre os melhores caminhos completos entre ele e todos os demais nós da rede. Lembre-se que este conjunto de caminhos forma uma árvore que conecta o nó local a todos os demais nós da rede. Assumindo, portanto, que haja um protocolo baseado em estado de enlaces utilizado para roteamento <em>unicast</em> na rede, basta que estas árvores de caminhos mais curtos encontradas por cada nó sejam disseminadas por toda a rede. Assim, quando um roteador recebe um pacote de <em>broadcast</em>, basta que ele consulte quais de suas portas de saída pertencem à árvore de caminhos mais curtos do nó de origem daquele pacote e faça o encaminhamento por elas.</p>
<p>Outra solução nesta família é o uso do encaminhamento baseado em <strong>caminho reverso</strong>, exatamente como utilizado no caso do roteamento <em>broadcast</em>: ao receber um pacote <em>multicast</em>, o roteador verifica se este foi recebido pela porta utilizada para encaminhar pacotes <em>unicast</em> para o nó de origem; em caso afirmativo, o roteador realiza a inundação do pacote para todas as suas portas de saída, exceto aquela pela qual o pacote foi recebido; caso contrário, o pacote é descartado.</p>
<p>Repare que a solução de encaminhamento baseado em caminho reverso é menos eficiente que a baseada na árvore de caminhos mais curtos, no sentido de que cada roteador pode receber um mesmo pacote múltiplas vezes — embora só encaminhe uma única vez. Por outro lado, a solução baseada nas árvores de caminho mínimo apresenta maior complexidade, dado que a informação de cada uma das árvores precisa ser disseminada por toda a rede e armazenada em cada roteador. Além disso, repare que ambas as soluções exigem a execução conjunta de um protocolo de roteamento <em>unicast</em>.</p>
<p>Por fim, note que ambas as soluções, como descritas até aqui, resultam em um <em>broadcast</em> — <em>i.e.</em>, os pacotes <em>multicast</em>, na prática, chegam a todos os nós da rede. Evitar este tipo de desperdício era justamente o propósito de estudarmos métodos específicos para o roteamento <em>multicast</em>. Na verdade, a diferença entre estas soluções e suas equivalentes aplicadas ao roteamento <em>broadcast</em> é a possibilidade de uso de um mecanismo adicional ainda não explicado até aqui: a <strong>poda</strong>.</p>
<p>A poda consiste em cortar das árvores <em>multicast</em> ramos que não são úteis. Por <em>não úteis</em>, entenda-se ramos que não contêm nem membros do grupo <em>multicast</em>, nem roteadores necessários para que pacotes alcancem membros.</p>
<p>Em uma solução distribuída, a poda geralmente funciona da seguinte forma. Ao receber um pacote destinado a um grupo <em>multicast</em>, um roteador decide por quais portas de saída deve encaminhá-lo. Caso o roteador decida que <strong>nenhuma das suas portas de saída faz parte da árvore e que ele próprio não é membro do grupo <em>multicast</em></strong>, então ele não é necessário àquele grupo. Com isso, este roteador envia uma mensagem de poda para seu pai na árvore. Ao receber esta mensagem, o roteador pai remove a porta pela qual a mensagem de poda chegou da árvore <em>multicast</em>. Note que isso pode fazer com que este próprio roteador pai chegue à conclusão de que agora não é mais necessário à árvore e, portanto, envie uma mensagem de poda para o seu pai. Este processo se repete até que a mensagem de poda alcance um roteador que ainda seja necessário à árvore.</p>
<h2 id="soluções-baseadas-em-árvores-compartilhadas">Soluções Baseadas em Árvores Compartilhadas</h2>
<p>Nesta família de soluções, nosso objetivo é determinar uma única árvore compartilhada por todos os membros do grupo <em>multicast</em>. Em geral, existem muitas possíveis árvores interconectando todos os membros de um grupo <em>multicast</em>. É importante, portanto, definir um critério de qual dessas devemos selecionar.</p>
<p>Assim como o roteamento <em>unicast</em> comumente se utiliza de métricas de roteamento para comparar dois ou mais caminhos, podemos, aqui, assumir que cada enlace da rede possui um peso — dado por uma métrica — o que possibilita comparar duas árvores <em>multicast</em> através da comparação dos custos totais de cada árvore. Em geral, o custo de uma árvore é dado pela soma dos pesos dos enlaces que a compõem. Assim, chegamos a um critério de escolha de uma árvore <em>multicast</em> que parece razoável: dentre as várias disponíveis, optaremos por aquela de menor custo total.</p>
<p>No entanto, dada uma topologia de rede e o conjunto de nós membros do grupo <em>multicast</em>, como podemos determinar esta árvore <em>multicast</em> de custo mínimo? Este é, na verdade, um problema clássico em computação — mais especificamente, na área de otimização — chamado de <strong>Problema da Árvore de Steiner em Grafos</strong>.</p>
<p>O Problema de Árvore de Steiner em Grafos tem grande aplicabilidade em diversos domínios, incluindo, por exemplo, o projeto de circuitos eletrônicos. Além disso, há grande interesse teórico no problema. Entretanto, foge ao escopo desta disciplina um estudo mais profundo sobre o problema e os algoritmos existentes para solucioná-lo. Para os nossos propósitos, é suficiente entendermos que este problema é classificado como NP-Difícil, o que significa — entre outras coisas — que, ao menos no momento, não são conhecidos algoritmos eficientes (<em>i.e.</em>, de tempo polinomial no tamanho da instância) para a sua solução. Dada a sua grande relevância, ao longo dos anos várias boas heurísticas — algoritmos que encontram soluções “boas”, mas não necessariamente ótimas — foram criadas para este problema. Mesmo assim, a aplicabilidade destas heurísticas para instâncias reais de larga escala tipicamente encontradas na área de roteamento <em>multicast</em> não é considerada prática, por conta de fatores como: a (ainda) alta complexidade computacional e de troca de mensagens, a necessidade (em certos métodos) de conhecimento sobre a topologia completa da rede e a natureza monolítica de várias destas heurísticas (<em>i.e.</em>, pequenas alterações nos participantes do grupo <em>multicast</em> demandam a re-execução completa do algoritmo).</p>
<p>Uma solução mais viável computacionalmente são as chamadas <strong>árvores baseadas em nó central</strong>. A ideia é simples: elege-se, dentre os membros do grupo <em>multicast</em>, um nó para atuar como nó central; em seguida, cada um dos demais membros do grupo <em>multicast</em> envia uma mensagem <em>unicast</em> do tipo <em>join</em> endereçada ao nó central; os enlaces percorridos pelas mensagens de <em>join</em> são adicionados à árvore <em>multicast</em> e posteriormente utilizados para o encaminhamento de pacotes no grupo.</p>
</body>
</html>
