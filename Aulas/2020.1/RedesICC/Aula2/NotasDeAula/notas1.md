# Internet: Arquitetura e Filosofias de Projeto

## Arquitetura da Internet

Na aula anterior, estudamos como é feita a interconexão dos dispositivos na Internet. Em particular, vimos que dispositivos se conectam através de enlaces e que, em um nível mais alto, a Internet é composta por um grande número de ISPs interconectados. Nessa aula, utilizaremos uma visão de ainda mais alto nível para estabelecer dois conceitos muito importantes: a _borda da rede_ e o _núcleo da rede_. Esses dois termos são utilizados para denotar duas "zonas" nas quais a Internet se divide, cada uma com características e responsabilidade distintas.

Na borda da rede estão localizados os *hosts* --- tanto os clientes quanto os servidores. Esses *hosts*, entretanto, necessitam de alguma infraestrutura --- enlaces, comutadores --- para se conectar ao resto da Internet. Em particular, encontramos também na borda da rede as chamadas _redes de acesso_, que realizam a conexão dos _hosts_ com o resto da Internet. O núcleo da rede é constituído por uma grande malha de comutadores interconectados. Esses roteadores pertencem às redes de grandes ISPs e outras entidades. Entre o núcleo e a borda da rede encontram-se os _roteadores de borda_, responsáveis pela conexão dessas duas zonas.

### Borda da Rede

Os *hosts*, localizados na borda da rede, são os dispositivos que executam as aplicações de rede. Conforme discutido na aula anterior, essas aplicações têm por característica a necessidade de comunicação com outras aplicações que (potencialmente) executam em outros *hosts*. Assim, aplicações de rede geram _mensagens_ que devem ser transmitidas pela rede até o *host* de destino.

A Internet é uma rede baseada em um conceito chamado de _comutação de pacotes_. Veremos com mais detalhes em aulas futuras o que isso significa, mas, por ora, basta sabermos que, nessas redes, o pacote é uma **unidade de transmissão de dados**. Em termos mais simples, um pacote carrega uma sequência de bits de uma mensagem potencialmente maior. Isso significa que nessas redes de comutação de pacotes --- e na Internet, por consequência --- os *hosts* quebram as mensagens potencialmente grandes das aplicações em pacotes antes de transmiti-los pela rede. 

Um *host* tipicamente estará conectado ao resto do mundo por um enlace ligado a um comutador. Uma característica importante dos pacotes é que eles são transmitidos de maneira individual pelos enlaces. Isto é, se uma mensagem de uma aplicação é quebrada em dois pacotes, o primeiro pacote terá que ser transmitido completamente pelo enlace antes que a transmissão do segundo possa começar.

Esse comutador ao qual o *host* se conecta muito provavelmente não faz parte do núcleo da rede. Ao contrário, ele deve compor a rede de acesso daquele *host*. Exemplos de rede de acesso incluem as redes domésticas e redes institucionais (*e.g.*, de uma universidade ou empresa). Essas redes de acesso se comunicam com o resto da Internet através de algum ISP de acesso e podem utilizar diversas tecnologias de enlace diferentes --- tanto para a comunicação interna na rede de acesso, quanto para a comunicação dessa com o ISP.

#### Tecnologias WAN

Um exemplo de tecnologia bastante utilizada para conectar redes de acesso a ISPs é o DSL (*Digital Subscriber Line*). Essa tecnologia --- ou família de tecnologias --- permite a transmissão de dados digitais em banda larga (*i.e.*, com altas taxas de transmissão) através da infraestrutura física de telefonia fixa. O uso da infraestrutura de telefonia fixa para transmissão de dados precede o DSL e começou com o uso de *modems* de linha discada. Na tecnologia de linha discada, o dispositivo cliente fazia uma chamada telefônica tradicional para um número do provedor de acesso e os dispositivos computacionais utilizavam-se sinais sonoros para transmitir dados. Além do inconveniente de ocupar a linha telefônica, essa estratégia esbarrava em uma série de limitações físicas que impediam taxas de transmissão mais elevadas de serem utilizadas. No DSL, ao contrário, os dados são transmitidos em uma outra _faixa de frequência_. Por isso, embora utilizem o mesmo meio físico, dados e voz podem ser separados, permitindo o uso da linha tanto para chamadas telefônicas quanto para conexão de dados simultaneamente. Além disso, o uso de outra faixa de frequência permite ao DSL evitar as restrições inerentes da faixa usada para a transmissão de voz, fazendo com que essa tecnologia possa atingir taxas de transmissão bem mais altas, comumente de vários Mb/s. Na sua vertente mais comum, denominada ADSL (*Asymmetric Digital Subscriber Line*), são usadas taxas diferentes para o *upstream* -- transmissão do cliente para o ISP --- e para o *downstream* --- transmissão do ISP para o cliente.

O fato do DSL utilizar a mesma infraestrutura física da telefonia fixa --- amplamente implantada em todo o mundo --- fez com que essa tecnologia se popularizasse rapidamente. Embora em grau menor, o mesmo ocorreu com o HFC (*Hybrid Fiber-Coaxial*). Como o nome sugere, redes HFC combinam o uso de enlaces de fibra óptica com enlaces baseados em cabos coaxiais. Esse tipo de cabeamento é amplamente utilizado para a distribuição de sinal de TV, incluindo por empresas do ramo de TV por assinatura, e possui boas características para a transmissão de dados. Isso fez com que muitas empresas que atuavam exclusivamente nesse ramo passassem a oferecer também serviço de acesso à Internet, já que não havia investimento necessário para levar o cabeamento ao endereço do cliente. Da mesma forma que o meio físico é compartilhado entre ligações telefônicas e dados no DSL, no HFC os dados são transmitidos em paralelo com os sinais dos canais de televisão. Uma diferença, no entanto, é que o cabeamento de telefone é exclusivo de um certo usuário, enquanto o de TV é tipicamente compartilhado por vários: por exemplo, um único cabo chega a um edifício e, através de divisores de potência, são criados "ramos" para cada um dos apartamentos. Isso faz com que o cabo coaxial em uma rede HFC seja um enlace compartilhado por vários usuários, levando também a uma divisão dos recursos físicos disponíveis. Esse cabeamento coaxial compartilhado conecta os clientes a uma central do ISP, a qual se conecta ao resto da Internet através de fibras ópticas.

Nas duas últimas décadas, outra família de tecnologias de acesso que vem ganhando muita popularidade é a das tecnologias de comunicação de dados por redes celular. As terceira, quarta e quinta gerações da telefonia celular suportam nativamente a transmissão de dados e proveem um grande nível de flexibilidade ao usuário impossível nas tecnologias cabeadas. Há também a facilidade de disseminação do serviço, dado que não é necessária a instalação de cabeamento até o endereço do cliente.

Essas e outras tecnologias são chamadas de _tecnologias de comunicação WAN_ (do inglês, *Wide Area Network*) e são voltadas para comunicações em longa distância.

#### Tecnologias LAN

Além das tecnologias de comunicação entre as redes de acesso e os ISP, há ainda outras tecnologias que são comumente empregadas entre os elementos internos da rede. Em uma rede doméstica, por exemplo, é comum hoje o emprego do Wi-Fi, uma tecnologia sem fio para comunicações de algumas dezenas de metros com taxas de transmissão típicas na casa das dezenas ou centenas de Mb/s --- embora "versões" mais recentes permitam taxas na casa dos Gb/s). Em ambientes institucionais, como empresas e universidades, é comum a utilização do Ethernet, uma tecnologia cabeada que atualmente taxas de vários Gb/s.

Ao contrário das tecnologias WAN, Wi-Fi e Ethernet são considerados tecnologias LAN (*Local Area Network*). A diferença está na área de abrangência: as redes LAN geralmente abrangem distâncias de dezenas ou poucas centenas de metros (*e.g.*, uma casa, um prédio).

#### PANs, BANs, RANs, MANs, ...

Além de WAN e LAN, há outras nomenclaturas para classificar tecnologias de acordo com a sua abrangência. Por exemplo, uma PAN (*Personal Area Network*) é uma rede composta por dispositivos pessoais de um usuário, como um *smartphone*, um fone de ouvido ou um *smartwatch*. Tecnologias de comunicação para esse tipo de rede, como o Bluetooth, geralmente envolvem enlaces de curto alcance. Já as BANs (*Body Area Network*) são redes de abrangência corporal, tipicamente empregadas para a comunicação de dispositivos médicos acoplados ao corpo, como sensores e atuadores. Nesse caso, as distâncias típicas dos enlaces são ainda mais curtas. Do outro lado do espectro, existem as redes de abrangência metropolitana (MAN) e regional (RAN), com enlaces bem mais longos.

### Núcleo da Rede

O núcleo da rede é formado basicamente por uma malha de comutadores interconectados. Aqui, o termo _malha_, denota que há múltiplos caminhos possíveis para que um pacote saia de um comutador e chegue a outro.

Em uma rede de comutação de pacotes, como a Internet, os pacotes originados nos *hosts* são _encaminhados_ de um comutador para o outro através dos enlaces entre eles até que o *host* de destino seja alcançado. Assim, esse encaminhamento é uma funcionalidade básica do núcleo da rede.

Embora o termo "encaminhamento" tenha sido usado aqui para dar uma ideia intuitiva de que os pacotes são enviados de um comutador para o próximo, trata-se na verdade de um termo técnico bem definido em redes de computadores. Em particular, o encaminhamento consiste em **mover um pacote recebido por um enlace de entrada para um enlace de saída do comutador**[^EnlacesDeSaida].

[^EnlacesDeSaida]: Enlaces muitas vezes são bidirecionais, *i.e.*, suportam transmissão tanto de $A$ para $B$ quanto de $B$ para $A$. Entretanto, no contexto de comutadores nos referiremos a _enlace de saída_ ou _enlace de entrada_ simplesmente para denotar que o pacote está chegando ou saindo do roteador, respectivamente.

Embora essa tarefa pareça trivial, note que um comutador pode possuir vários enlaces com vários outros comutadores. Assim, podem existir múltiplas opções de enlace de saída. Como, então, um comutador escolhe o enlace de saída _correto_? A resposta está em uma segunda funcionalidade básica do núcleo da rede: o _roteamento_.

De forma simplificada, o roteamento é um processo através do qual um dispositivo levanta informações sobre a rede com o objetivo de traçar caminhos --- *i.e.*, sequências de enlaces consecutivos a serem percorridos --- dele para os demais dispositivos. Lembre-se que o núcleo da rede consiste de uma malha de enlaces, o que significa que em condições normais deve haver múltiplos caminhos alternativos. Assim, o roteamento normalmente envolve também algum critério de escolha de um *bom* caminho. Nesse momento do curso, não entraremos em detalhes de como funciona o roteamento ou mesmo sobre o que seria um *bom* caminho --- este tópico será estudado em detalhes no último capítulo do curso. Por ora, basta entendermos que o processo de roteamento existe e que ele determina as tais rotas.

O produto final do roteamento é representado na forma de tabelas armazenadas nos vários dispositivos que compõem a rede --- comutadores ou *hosts*. Na verdade, cada dispositivo armazena na sua _tabela de roteamento_ apenas um pedaço das informações dos caminhos encontrados pelo roteamento: a informação do primeiro enlace. Isso é suficiente para que esse dispositivo saiba por qual enlace de saída deve enviar o pacote para que esse comece a percorrer o caminho selecionado pelo roteamento --- o resto da informação da informação do caminho fica armazenada nos demais dispositivos, que se encarregam de continuar o encaminhamento até o destinatário.

Em resumo, o núcleo da rede opera através da execução e colaboração dessas duas funcionalidades básicas: o roteamento e o encaminhamento. A primeira determina os caminhos a serem utilizados, enquanto a segunda utiliza esses caminhos para encaminhar os pacotes. **A colaboração entre essas duas funcionalidades é feita através de uma tabela de roteamento, construída pelo roteamento e consultada pelo encaminhamento**. Cada entrada dessa tabela associa um destinatário de pacote ao enlace de saída que deve ser utilizado.

#### Rotas na Internet

Como usuários finais da Internet, geralmente não estamos preocupados com as rotas utilizadas por nossos pacotes, desde que os mesmos cheguem --- rapidamente --- ao seu destino final. Entretanto, muitas vezes é importante conhecer essas rotas, seja para depurarmos problemas de funcionamento da rede ou, no caso específico desse curso, adquirirmos conhecimento sobre o funcionamento da Internet. De fato, é normalmente possível descobrir --- ainda que aproximadamente --- a rota usada entre determinados dispositivos da Internet. Sistemas operacionais geralmente trazem um utilitário denominado `traceroute` exatamente para esse propósito.

O funcionamento do `traceroute` é surpreendentemente simples. Basicamente, ele gera um pacote destinado ao alvo desejado e inclui nesse pacote a informação de que o mesmo deve percorrer, no máximo, um enlace --- ou um _salto_, no jargão do roteamento. O pacote é, então, enviado e começa a percorrer a rota que desejamos descobrir. Ao atravessar o primeiro enlace, o comutador intermediário percebe que o número de saltos máximo especificado pela origem foi alcançado e, como resultado, envia de volta para a origem uma mensagem de alerta. Ao receber esse alerta, o `traceroute` descobre qual comutador se encontra a um salto de distância no caminho. O programa procede, agora gerando uma nova versão do pacote, dessa vez limitando o número de saltos a 2. Esse processo continua até que eventualmente o pacote alcance o destinatário final, permitindo que o `traceroute` descubra todos os comutadores percorridos até lá.

Obviamente, essa explicação omite uma série de detalhes. Em particular, podemos nos perguntar:

1. Como `traceroute` é capaz de informar no pacote o número máximo de saltos a serem percorridos?
1. Como o comutador intermediário sabe quem é a origem para mandar o alerta de que o limite de saltos foi alcançado?
1. Como o `traceroute sabe que o pacote chegou ao destinatário final e, portanto, o caminho completo já foi descoberto?

No último capítulo desse curso estudaremos todos os mecanismos necessários ao funcionamento do `traceroute` e seremos capazes de responder a todas essas perguntas. No momento, entretanto, o objetivo é apenas criamos um entendimento básico do que são rotas e com o que uma rota típica da Internet se parece. Para isso, vamos analisar a saída de uma execução do `traceroute` de computador na UFF para o servidor *web* da Universidade de Tóquio (www.u-tokyo.ac.jp): 


```
 1  192.168.128.254 (192.168.128.254)  0.149 ms  0.133 ms  0.158 ms
 2  * * *
 3  rt-borda-val-0-129.cte.sti.uff.br (200.20.0.129)  0.519 ms  0.519 ms  0.508 ms
 4  200.20.92.145 (200.20.92.145)  1.449 ms  1.490 ms  1.513 ms
 5  170.79.213.48 (170.79.213.48)  1.162 ms  1.151 ms  1.140 ms
 6  170.79.213.1 (170.79.213.1)  10.627 ms  10.287 ms  10.285 ms
 7  ce-mg-oi.bkb.rnp.br (200.143.252.142)  48.965 ms  48.956 ms  49.000 ms
 8  170.79.213.47 (170.79.213.47)  113.278 ms  113.276 ms  113.255 ms
 9  xe-0-0-26-2.a01.miamfl02.us.bb.gin.ntt.net (129.250.202.93)  113.847 ms  113.830 ms  113.818 ms
10  ae-5.r04.miamfl02.us.bb.gin.ntt.net (129.250.3.209)  283.545 ms  283.422 ms  283.440 ms
11  ae-1.r21.miamfl02.us.bb.gin.ntt.net (129.250.4.88)  114.038 ms ae-0.r21.miamfl02.us.bb.gin.ntt.net (129.250.4.20)  113.505 ms  113.481 ms
12  ae-2.r24.dllstx09.us.bb.gin.ntt.net (129.250.2.219)  143.271 ms  144.634 ms  144.610 ms
13  ae-5.r22.lsanca07.us.bb.gin.ntt.net (129.250.7.69)  181.203 ms  176.513 ms  181.163 ms
14  ae-15.r25.osakjp02.jp.bb.gin.ntt.net (129.250.2.177)  284.174 ms  291.470 ms  287.510 ms
15  ae-2.r03.osakjp02.jp.bb.gin.ntt.net (129.250.7.33)  282.424 ms  284.722 ms ae-2.r02.osakjp02.jp.bb.gin.ntt.net (129.250.2.128)  283.441 ms
16  ae-2.a01.osakjp02.jp.bb.gin.ntt.net (129.250.3.106)  284.731 ms  290.450 ms  313.690 ms
17  xe-0-0-22-3.a01.osakjp02.jp.ce.gin.ntt.net (61.200.80.218)  290.923 ms  290.913 ms  285.799 ms
18  158.205.192.173 (158.205.192.173)  290.936 ms  289.212 ms  283.946 ms
19  158.205.192.86 (158.205.192.86)  299.191 ms  299.084 ms  297.543 ms
20  158.205.121.38 (158.205.121.38)  295.744 ms  311.682 ms  295.742 ms
21  210-152-243-234.jp-west.compute.idcfcloud.com (210.152.243.234)  305.124 ms  299.602 ms  298.511 ms
22  210-152-243-234.jp-west.compute.idcfcloud.com (210.152.243.234)  303.649 ms  285.976 ms  291.210 ms
```

Cada linha da saída representa, em ordem, um salto do caminho determinado pelo `traceroute`. Após um identificador numérico de cada linha, o `traceroute` imprime o identificador do comutador relativo àquele salto. Note que, em certas linhas, esse identificador é impresso em uma forma "textual" seguida de uma forma "numérica" entre parêntesis (*e.g.*, ```rt-borda-val-0-129.cte.sti.uff.br (200.20.0.129)```). Esse identificador numérico é chamado de _endereço IP_, um tipo de endereço usado na internet para identificar dispositivos. Já os identificadores textuais são os *hostnames*, uma *string* associadas ao endereço IP que descreve o dispositivo de forma (espera-se) mais amigável. No entanto, nem todo dispositivo possui um *hostname* associado: nesse caso, o `traceroute` simplesmente repete o endereço IP no lugar do *hostname*. 

Quando o *hostname* existe, podemos usá-lo para inferir algumas informações sobre o comutador. Por exemplo, repare no *hostname* do terceiro salto: `rt-borda-val-0-129.cte.sti.uff.br`. A *string* começa por "rt-borda", indicando que se trata de um _roteador de borda_, *i.e.*, um roteador conectando uma rede de acesso ao mundo externo. A *string* termina em ".uff.br", indicando que se trata de um dispositivo administrado pela UFF. Mais especificamente, o nome termina em "sti.uff.br", sugerindo que o dispositivo em questão é administrado pelo STI (Superintendência de Tecnologia da Informação) da UFF. Outros exemplos de informações que podem ser inferidas pelo *hostname* incluem:

- No salto 7, a *string* contém "bkb.rnp.br", indicando que se trata de um comutador do *backbone* da *RNP* (Rede Nacional de Ensino e Pesquisa, entidade que, entre outras responsabilidades, atua como ISP para instituições de ensino e pesquisa no Brasil).
- No salto 10, a *string* contém "miamfl02.us.bb.gin.ntt.net", sugerindo se tratar de um equipamento da NTT (*Nippon Telegraph and Telephone*, um dos maiores ISPs do mundo), localizado nos Estados Unidos ("us"), mais especificamente em Miami, na Flóriada ("miamfl02").
- A partir do salto 14, os *hostnames* incluem sempre "jp", indicando se tratar de equipamentos localizados no Japão.

Além dos identificadores do salto, o `traceroute` imprime também três tempos (nesse exemplo, todos em milissegundos). Esses tempos correspondem a uma medida de desempenho bastante comum em redes chamada de RTT (do inglês *Round-Trip Time*, ou, simplesmente, _Tempo de Ida e Volta_). O RTT é o tempo desde a transmissão de um pacote por um dispositivo de origem até que uma resposta seja recebida de volta. No caso do `traceroute`, esse tempo corresponde ao intervalo entre o envio de um pacote até o momento em que o alerta do *i-ésimo* salto é recebido pela origem informando que o número máximo de saltos foi alcançado. O `traceroute` apresenta três valores de RTT em cada linha porque ele repete três vezes o envio de pacote para cada salto do caminho.

Assim como o *hostname* pode nos dar uma série de informações sobre os saltos de um caminho, os valores de RTT também contém informações úteis. Por exemplo, repare que até o terceiro salto os tempos são muito baixos, sempre abaixo dos 520 $\mu s$. Entre o terceiro e quarto saltos esse tempo aumenta consideravelmente, excedendo 1 ms. Isso pode indicar um enlace "lento", mas mais provavelmente aponta para um enlace de maior extensão geográfica. Em particular, nesse salto o pacote sai da rede de acesso e passa por um enlace de maior distância. Entre os saltos 5 e 6 há um novo aumento abrupto de RTT, sugerindo que o enlace em questão é ainda mais longo. Fenômenos similares acontecem entre os saltos 7 e 8 (um enlace aparentemente entre países diferentes) e entre os saltos 13 e 14 (um enlace aparentemente intercontinental).

Pode-se observar também que a segunda linha da saída tem formato bastante diferente das demais: ela mostra apenas três asteriscos. O `traceroute` imprime um asterisco sempre que não recebe resposta a um pacote enviado. Essa ausência de resposta pode ocorrer por vários motivos. Por exemplo, o pacote pode ter sido _perdido_ --- *i.e.*, pode ter havido algum erro durante seu encaminhamento e ele nunca chegou até o comutador correspondente àquele salto. Pode ser também que o comutador em questão tenha recebido o pacote corretamente, mas tenha sido configurado para não gerar uma resposta. Isso é relativamente comum na Internet atual: administradores muitas vezes fazem esse tipo de configuração para evitar gastar recursos da sua rede com esse tipo de resposta; a motivação pode ser também segurança, uma vez que os tipos de pacotes usados pelo `traceroute` podem em alguns casos ser usados para perpetrar ataques cibernéticos.

Como última observação sobre a saída do `traceroute`, observe a linha 11. Nela, há dois comutadores diferentes sendo identificados. O primeiro, denominado `ae-1.r21.miamfl02.us.bb.gin.ntt.net`, respondeu ao primeiro pacote usado pelo `traceroute` para identificar o décimo primeiro salto. O segundo, denominado `ae-0.r21.miamfl02.us.bb.gin.ntt.net`, respondeu ao segundo e ao terceiro pacotes. Mas como isso é possível? Como pode haver dois comutadores diferentes na mesma posição de um caminho?

A resposta é que houve uma _mudança de rota_ durante a execução do `traceroute`. Isso é, entre o momento em que o `traceroute` gerou o primeiro e o segundo pacotes relativos ao décimo primeiro salto, o processo de roteamento da Internet decidiu pela alteração da rota. Enquanto na rota antiga, o décimo salto era o comutador `ae-1.r21.miamfl02.us.bb.gin.ntt.net`, na rota nova ele passou a ser o `ae-0.r21.miamfl02.us.bb.gin.ntt.net` --- repare que outros saltos anteriores podem ter sido mudados também, mas o `traceroute` não volta atrás para verificá-los. Isso destaca uma característica importantíssima das rotas na Internet: elas são dinâmicas e, portanto, podem mudar a qualquer momento. Mais que isso, pacotes gerados por uma mesma aplicação --- nesse caso, o `traceroute` --- podem ser encaminhados por rotas diferentes. Uma consequência ainda mais estranha é que um pacote transmitido pela origem _depois_ pode chegar _antes_ ao destinatário final --- por exemplo, porque o caminho novo é mais rápido.

## Filosofias e Princípios de Projeto da Internet

Embora ainda não tenhamos entrado em detalhes sobre o funcionamento da Internet, já deve ser possível perceber que se trata de um sistema bastante complexo. É uma rede com **bilhões de dispositivos**, esses dispositivos são **heterogêneos**, administrados por **entidades diferentes** que têm liberdade para seguir **políticas de administração diferentes**. Além disso, o **volume** de informação que trafega na rede a cada **segundo** é enorme. Considere, ainda, o fato de que esse tráfego viabiliza hoje uma série de **atividades econômicas e sociais fundamentais** para a sociedade moderna.

Todos esses fatores exercem uma grande pressão no projeto da Internet e nas soluções e protocolos utilizados para implementá-lo. Em particular, por se tratar de uma rede tão heterogênea --- tanto em termos de *hardware* quanto em termos de *administração* --- existe uma necessidade de uniformização, *i.e.*, da definição de alguns princípios básicos que devem ser seguidos por todos os participantes da rede.

Na aula anterior, discutimos brevemente uma das ferramentas utilizadas para essa uniformização: o estabelecimento de protocolos de rede, determinando como esses diferentes dispositivos devem se comunicar uns com os outros. No entanto, apenas estabelecer regras rígidas para como a comunicação deve ser realizada na Internet não é suficiente. Ao contrário, os protocolos usados na Internet precisam ser flexíveis, no sentido de não assumir muita coisa a respeito dos dispositivos da rede. Para entender o porquê, considere um protocolo hipotético que só funcione de maneira correta em dispositivos conectados ao restante da Internet por enlaces de, ao menos, 1 Gb/s. Segundo um relatório da Akamai --- uma grande empresa do ramo de distribuição de conteúdo na Internet ---, em 2016 o país com maior velocidade média de acesso à Internet no mundo era a Coreia do Sul, onde, em média, usuários finais se conectavam a 28,6 Mb/s --- muito abaixo dos 1 Gb/s requeridos pelo nosso protocolo hipotético.

Assim, tal protocolo seria suportado por uma fração muito pequena da rede atual. Embora para certos protocolos isso possa ser aceitável --- por exemplo, jogos frequentemente impõem requisitos mínimos que nem sempre são atendidos pelos potenciais usuários ---, esse tipo de restrição não pode estar presente nos protocolos básicos da Internet --- justamente aqueles que garantem a interoperabilidade dos dispositivos heterogêneos.

Como veremos a seguir, esse tipo de consideração vem guiando decisões de projeto na Internet desde suas origens.

### O Argumento Fim-a-Fim

O *Internet Architecture Board* é um comitê que foi criado em 1979 pela DARPA para supervisionar e guiar o desenvolvimento arquitetural e de padrões na Internet. De 1981 a 1989, esse comitê foi dirigido por David Clark, atualmente um pesquisador no MIT. Durante esse período, Clark esteve diretamente envolvido com decisões de projeto fundamentais que tiveram --- e ainda tem --- impacto profundo no funcionamento da Internet.

Entre suas inúmeras contribuições, ele publicou em 1988 um artigo intitulado *"The Design Philosophy of the DARPA Internet Protocols"* que introduz o chamado _Argumento Fim-a-Fim_, um princípio que tem guiado o projeto da Internet ao longo dos anos[^ArgFimAFimExceções]. Resumidamente, o Argumento Fim-a-Fim defende que uma funcionalidade só pode ser implementada de forma **correta e completa** se isso for feito com o auxílio das aplicações executadas nas **pontas do sistema de comunicação**.

[^ArgFimAFimExceções]: Embora existam várias exceções, conforme veremos ao longo deste curso.

No artigo, Clark provê uma série de exemplos para corroborar essa afirmação. Um deles é o de uma aplicação de transmissão de arquivos entre dois computadores. Os computadores estão conectados por algum tipo de rede de comunicação baseada em comutação de pacotes. Isso significa que o arquivo --- potencialmente grande --- será quebrado em um ou mais pacotes. Além disso, Clark assume que pacotes podem ser corrompidos ao serem transmitidos pelos enlaces, o que, de fato, ocorre em redes reais. Dadas todas essas hipóteses, nossa aplicação tem como objetivo fazer com que o arquivo chegue *íntegro* ao destinatário. Integridade, aqui, significa que a cópia do arquivo gravada em memória no computador de destino será idêntica, bit a bit, à cópia original no computador de origem.

Como uma tentativa inicial, vamos contrariar o Argumento Fim-a-Fim e supor que a funcionalidade de garantir a integridade dos dados seja implementada totalmente pela rede. Ou seja, a rede conterá mecanismos que garantem que a sequência de bits entregue ao computador de destino da aplicação será idêntica à sequência armazenada na memória do computador de origem. Como pacotes podem ser corrompidos durante a transmissão pelos enlaces, isso significa que, de alguma maneira, todo *host*/comutador precisa verificar a integridade dos pacotes recebidos[^VerificaçãoDeIntegridade]. Caso o pacote recebido não seja íntegro, o *host*/comutador requisita uma _retransmissão_. Além disso, vimos também que na Internet pacotes podem chegar _fora de ordem_ --- por exemplo, por mudanças no roteamento. Assim, de alguma forma, a rede deve evitar essa situação e garantir que os pacotes sejam entregues ao destinatário na exata ordem em que saíram da origem.

[^VerificaçãoDeIntegridade]: Mecanismos de verificação de integridade de pacotes existem e são bastante utilizados em redes de computadores. Por ora, não entraremos em detalhes como eles funcionam. No terceiro capítulo desse curso veremos um exemplo. 

Esse conjunto de mecanismos é suficiente para garantir a integridade do arquivo no receptor? Infelizmente, não. E por vários motivos. Por exemplo:

- Quem garante que o arquivo estava íntegro quando *saiu* do *host* de origem?
	- A leitura do arquivo a partir do disco pode ter sofrido alguma corrupção.
- Quem garante que não houve alguma falha na verificação de integridade de algum pacote em algum salto?
- Quem garante que as implementações dos comutadores/*hosts* estão absolutamente corretas (*i.e.*, não há bugs)?

Todos esses fatores fazem sugerem que, em última instância, o receptor ainda deve realizar uma verificação de integridade do arquivo completo recebido. Nesse caso, devemos nos perguntar: se a implementação da "garantia" de integridade na rede não é 100% eficaz, é desejável que essa funcionalidade seja implementada? Possivelmente não, dado que:

- A implementação dessa funcionalidade adiciona complexidade à rede.
	- Um sistema já bastante complexo se torna ainda mais difícil de projetar, implementar e manter.
- Tal implementação assume certas características dos comutadores intermediários.
	- Por exemplo, todos devem ter capacidade de processamento e memória suficientes para executar o algoritmo de verificação e a funcionalidade de retransmissão.
- Ela também causa efeitos colaterais para certas aplicações.
	- Retransmissões aumentam o tempo até a entrega de um pacote. Algumas aplicações não necessitam de integridade, mas são prejudicadas por atrasos excessivos na entrega dos dados.

Consideremos agora a aplicação do Argumento Fim-a-Fim ao projeto desse sistema. Basicamente, aceitaremos o fato de que o *host* de destino ainda precisará ele próprio verificações de integridade dos dados recebidos e abriremos mão de manter essa funcionalidade também na rede. Nesse caso, os bits do arquivo podem chegar corrompidos --- ou faltando --- no destinatário que (espera-se) detectará a falha de integridade e requisitará retransmissões diretamente à origem. Note que da mesma forma que a verificação de integridade pode falhar na implementação pela rede, ela também pode falhar quando executada pelo *host* de destino --- *e.g.*, pode haver um *bug* no código de verificação ou uma falha de *hardware* durante a execução. Entretanto, temos como vantagem a ausência de redundância na implementação da funcionalidade: apenas o *host* precisa implementá-la, simplificando o projeto, implementação e manutenção da rede.

Repare que o Argumento Fim-a-Fim é uma **filosofia geral de projeto**, mas não uma verdade absoluta. Conforme veremos nessa disciplina --- e em Redes de Computadores II ---, é possível encontrar uma série de exceções a essa filosofia em protocolos e mecanismos utilizados na Internet. Em geral, essas exceções estão ligadas a benefícios de desempenho ao se implementar determinado mecanismo na rede, ao invés de delegá-lo (totalmente) as pontas da comunicação. Por exemplo, voltando à aplicação de transmissão de arquivos, um benefício de realizar a verificação de integridade salto a salto é que corrupções dos pacotes podem ser recuperadas mais rapidamente. Isso porque, no caso fim-a-fim, a detecção da corrupção e solicitação de uma nova cópia do pacote só acontecem quando esse chega ao destinatário, o que faz com que o tempo total para a versão íntegra chegar também aumente. Além disso, **recursos da rede podem ser desperdiçados** com a transmissão por vários enlaces de um pacote corrompido anteriormente. 

Assim, em certos **casos particulares** otimizações são realizadas em desacordo com o Argumento Fim-a-Fim. No entanto, o Argumento Fim-a-Fim é majoritariamente seguido no projeto arquitetural e de protocolos da Internet. Veremos inúmeros exemplos disso ao longo desse curso.

#### Argumento Fim-a-Fim: Analogias

Embora o argumento Fim-a-Fim seja uma filosofia de projeto aplicável a redes de comunicação, é possível encontrar paralelos com conceitos aplicados em outras áreas. Por exemplo, na área de arquitetura de computadores, há o embate entre arquiteturas RISC (*Reduced Instruction Set Computer*) e CISC (*Complex Instruction Set Computer*). Uma arquitetura CISC implementa um conjunto grande de instruções de máquina, suprindo, assim, em *hardware* grande parte das operações tipicamente realizadas pelas aplicações. Já uma arquitetura RISC oferece um conjunto de instruções comparativamente menor, focando em oferecer um mínimo de operações em *hardware* que sejam suficientes para que as funcionalidades mais complexas sejam implementadas em *sofware*. Embora fuja ao escopo dessa disciplina discutir os méritos de cada abordagem, os defensores de arquiteturas RISC argumentam que o menor conjunto de instruções torna os processadores mais simples, menos susceptíveis a *bugs* e pode trazer benefícios de desempenho ao permitir implementações mais eficientes das instruções básicas oferecidas. Tais argumentos são bem similares aos usados para justificar o argumento Fim-a-Fim.

Outro exemplo é o princípio da Navalha de Occam. Esse princípio filosófico defende que, dadas duas explicações consistentes para um mesmo fenômeno, é preferível optar pela mais simples --- *i.e.*, a que contém o menor número de suposições. Esse princípio é frequentemente utilizado em ciência para a explicação de fenômenos observados. Uma das razões para isso é ideia intuitiva de que, quanto menor o número de hipóteses não testadas em uma explicação para um dado fenômeno, menor a probabilidade de que essa explicação venha a ser refutada futuramente --- por exemplo, por novas observações inconsistentes com a explicação ou através de contraprovas às hipóteses. Assim como no caso do Argumento Fim-a-Fim, opta-se pela simplicidade, em detrimento a complexidades adicionais injustificadas.

#### Argumento Fim-a-Fim: Inteligência nas Bordas

Um corolário do Argumento Fim-a-Fim é a tendência na Internet de se **manter a complexidade nas bordas**. Dito de outra forma, o projeto da Internet busca manter o **núcleo da rede simples**, ao concentrar a **inteligência nas bordas**.

Como os elementos do núcleo da rede tendem a processar um volume muito maior de pacotes que os da borda, objetiva-se mantê-los o mais simples e especializados o possível, de forma que eles possam exercer essas poucas funcionalidades de maneira bastante eficiente. Em última análise, ao manter o núcleo da rede simples, aumentamos a capacidade de **escalabilidade** da Internet --- em termos de suportar demandas crescentes de usuários e tráfego. Já nas bordas, como o volume de pacotes processados é tipicamente menor, pode-se dar ao luxo de realizar tarefas mais complexas, já que a pressão por escalabilidade é mais baixa.

Embora posto nesses termos o conceito de inteligência nas bordas possa parecer uma opção óbvia, vale destacar que nem toda rede de comunicação é assim. De fato, outra rede de comunicação extremamente popular adota o paradigma exatamente oposto: na telefonia fixa, o núcleo concentra a enorme maioria das funcionalidades, enquanto os terminais --- aparelhos de telefone --- são bastante simples.

### O Princípio KISS

Outra filosofia geral de projeto amplamente adotada na Internet é o chamado _princípio KISS_ (do inglês, *Keep It Simple, Stupidy!*). Esse princípio foi originado na Marinha Americana na década de 1960, mas foi incorporado às filosofias que guiam o desenvolvimento da Internet desde os seus primórdios. O princípio KISS defende que sistemas _funcionam melhor_ quando são mantidos **simples**. Partindo dessa premissa, a simplicidade deve ser um objetivo do projeto. Assim, quaisquer complexidades que não sejam absolutamente necessárias aos requisitos do sistema deve ser evitadas.

O princípio KISS é aplicável a qualquer projeto de computação ou engenharia. No caso particular da Internet, ele se manifesta principalmente na forma de projetos de protocolos simples (relativamente falando). Quanto mais simples é um protocolo, mais fácil é sua implementação, depuração e extensão. Ao longo de todo o curso, veremos exemplos de opções por simplicidade em diversos protocolos amplamente utilizados na Internet.
