<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Roteamento baseado em Vetor de Distâncias</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Roteamento baseado em Vetor de Distâncias</h1>
</header>
<p>Ao contrário do roteamento baseado em Estado de Enlaces, que utiliza um algoritmo sequencial para encontrar os caminhos mínimos, no roteamento baseado em vetor de distância utiliza-se um algoritmo distribuído para o cálculo das melhores rotas. Isso significa que cada roteador que executa o protocolo de roteamento baseado em vetor de distância realizará uma parte do processamento do algoritmo e, através da troca de mensagens com seus <strong>vizinhos diretos</strong>, roteadores colaborarão para determinar as melhores rotas.</p>
<p>Da mesma maneira que o Algoritmo de Dijkstra é quase sempre usado como o algoritmo de caminhos mínimos pelos protocolos de roteamento baseados em Estado de Enlaces, o <strong>Algoritmo de Bellman-Ford</strong> é o utilizado pelos protocolos baseados em Vetor de Distâncias. Este algoritmo utiliza o paradigma de <strong>programação dinâmica</strong>, no qual as soluções para partes mais simples do problema são pré-computadas e armazenadas para, posteriormente, simplificarem a solução de partes mais complexas. Colocando isso em termos de roteamento, o Algoritmo de Bellman-Ford encontra primeiro as rotas ótimas com poucos saltos e depois as utiliza como base para encontrar as rotas ótimas que possuem mais saltos.</p>
<p>A ideia central do Algoritmo de Bellman-Ford é resumida na chamada Equação de Bellman-Ford:</p>
<p><br /><span class="math display"><em>d</em><sub><em>x</em></sub>(<em>y</em>) = <em>m</em><em>i</em><em>n</em><sub><em>v</em></sub>{<em>c</em>(<em>x</em>,<em>v</em>)+<em>d</em><sub><em>v</em></sub>(<em>y</em>)},</span><br /></p>
<p>onde <span class="math inline"><em>d</em><sub><em>x</em></sub>(<em>y</em>)</span> e <span class="math inline"><em>d</em><sub><em>v</em></sub>(<em>y</em>)</span> denotam as distâncias dos caminhos mais curtos de <span class="math inline"><em>x</em></span> e de <span class="math inline"><em>v</em></span> até <span class="math inline"><em>y</em></span> e <span class="math inline"><em>c</em>(<em>x</em>, <em>v</em>)</span> denota o custo do enlace de <span class="math inline"><em>x</em></span> para <span class="math inline"><em>v</em></span>. Basicamente, o que esta equação diz é que o melhor caminho do nó <span class="math inline"><em>x</em></span> para um certo destinatário <span class="math inline"><em>y</em></span> é necessariamente composto pelo enlace de <span class="math inline"><em>x</em></span> para um de seus vizinhos anexado do melhor caminho deste vizinho para o destinatário <span class="math inline"><em>y</em></span>. A partir desta observação, se, de alguma forma, assumirmos que <span class="math inline"><em>x</em></span> conhece os custos dos caminhos mais curtos de cada um de seus vizinhos até <span class="math inline"><em>y</em></span>, basta que <span class="math inline"><em>x</em></span> some a estes valores os pesos dos seus enlaces para cada um destes vizinhos e verifique qual soma resulta no menor valor. Este valor será, certamente, o custo do caminho mínimo de <span class="math inline"><em>x</em></span> para <span class="math inline"><em>y</em></span> e o próximo salto neste caminho ótimo é o vizinho <span class="math inline"><em>v</em></span> de <span class="math inline"><em>x</em></span> associado a este custo mínimo.</p>
<p>Repare que este raciocínio não fornece a <span class="math inline"><em>x</em></span> a rota completa até <span class="math inline"><em>y</em></span>, apenas seu custo e o próximo salto. Estas informações, no entanto, são suficientes para a construção da tabela de roteamento.</p>
<p>A Equação de Bellman-Ford, no entanto, não especifica como um nó <span class="math inline"><em>x</em></span> obtém estas distâncias mais curtas de seus vizinhos até <span class="math inline"><em>y</em></span>. Se um vizinho <span class="math inline"><em>v</em></span> de <span class="math inline"><em>x</em></span> soubesse, com certeza, qual é a sua distância mínima até <span class="math inline"><em>y</em></span>, ele poderia simplesmente anunciá-la a <span class="math inline"><em>x</em></span> através do envio de uma mensagem. Entretanto, como <span class="math inline"><em>v</em></span> determina esta distância? Ele poderia utilizar a própria Equação de Bellman-Ford, mas para isso precisaria receber as distâncias mínimas de todos os seus vizinhos até <span class="math inline"><em>y</em></span>. Podemos continuar estendendo este raciocínio para outros nós, mas repare que estamos apenas criando uma cadeia informações que rapidamente resulta em uma dependência cíclica (<em>e.g.</em>, <span class="math inline"><em>x</em></span> precisa da melhor distância de <span class="math inline"><em>v</em></span> para <span class="math inline"><em>y</em></span>; para calculá-la, <span class="math inline"><em>v</em></span> precisa da melhor distância de <span class="math inline"><em>x</em></span> para <span class="math inline"><em>y</em></span>).</p>
<p>Felizmente, esta dependência cíclica pode ser resolvida através de um processo iterativo no qual cada nó recebe <strong>estimativas</strong> dos custos mínimos de seus vizinhos para outros destinatários e, com base nelas e na Equação de Bellman-Ford, gera suas próprias estimativas. É possível demonstrar que, sob condições que são <strong>razoáveis na prática</strong>, este processo gradualmente converge para que todos os nós da rede encontrem os custos mínimos deles para cada destinatário da rede e o nó de próximo salto na rota ótima associada.</p>
<p>Mais especificamente, o Algoritmo de Bellman-Ford funciona da seguinte forma:</p>
<ol type="1">
<li><p><strong>Inicialização</strong>. Cada nó mantém uma estrutura de dados chamada de <strong>Vetor de Distâncias</strong>, na qual o nó armazena o custo mais baixo conhecido dele para cada um dos demais nós da rede — <em>i.e.</em>, as entradas do vetor de distâncias mantido pelo nó <span class="math inline"><em>x</em></span> serão os valores <span class="math inline"><em>D</em><sub><em>x</em></sub>(<em>y</em>)</span> para todos os demais nós <span class="math inline"><em>y</em></span> da rede. No início da execução do algoritmo, cada nó conhece apenas os pesos dos seus enlaces para seus vizinhos diretos. Por isso, o vetor de distâncias de um nó é inicializado para conter estes pesos como estimativas iniciais das distâncias para seus vizinhos e <strong>infinito</strong> para os demais nós da rede.</p></li>
<li><p><strong>Envio do Vetor de Distâncias</strong>. Após gerar esta versão inicial do seu Vetor de Distâncias, um nó o envia para cada um de seus vizinhos diretos.</p></li>
<li><p><strong>Recebimento de um Vetor de Distâncias</strong>. Ao receber um Vetor de Distâncias de um vizinho, um nó deve varrer todos os destinatários da rede verificando se é possível melhorar sua estimativa dos custos mínimos considerando o peso de seu enlace para este vizinho e os custos que o vizinho está reportando através do seu vetor de distância. Mais especificamente, se <span class="math inline"><em>x</em></span> recebe o Vetor de Distâncias do seu vizinho <span class="math inline"><em>v</em></span>, para cada destinatário <span class="math inline"><em>y</em></span>, <span class="math inline"><em>x</em></span> deve calcular a soma <span class="math inline"><em>c</em>(<em>x</em>, <em>v</em>) + <em>d</em><sub><em>v</em></sub>(<em>y</em>)</span> e compará-la com sua estimativa atual <span class="math inline"><em>d</em><sub><em>x</em></sub>(<em>y</em>)</span>. Caso a soma seja mais baixa, <span class="math inline"><em>x</em></span> atualiza sua estimativa do seu custo mínimo para <span class="math inline"><em>y</em></span>, armazenando que o próximo salto na rota associada é <span class="math inline"><em>v</em></span>.</p></li>
<li><p><strong>Atualização do Vetor de Distância</strong>. Toda vez que houver uma mudança em pelo menos uma das entradas do seu Vetor de Distâncias, o nó deve reenviá-lo para seus vizinhos para que estes possam atualizar suas próprias informações.</p></li>
</ol>
<p>Para uma rede totalmente estática, após a convergência do algoritmo os nós poderiam simplesmente parar sua execução. No entanto, redes de computadores são normalmente dinâmicas, podendo haver mudanças topológicas — menos frequentes — ou dos custos dos enlaces — mais frequente. Por este motivo, protocolos de roteamento baseados em Vetor de Distâncias continuam executando o algoritmo de Bellman-Ford indefinidamente, mesmo após a convergência inicial. Cada nó é responsável por monitorar a sua vizinhança e, caso alguma alteração seja detectada — <em>e.g.</em>, surgimento, desaparecimento ou mudança de custo de algum enlace —, o nó deve re-computar seu vetor de distâncias de acordo. Qualquer alteração do Vetor de Distâncias demanda que o nó o retransmita para seus vizinhos — para que estes possam atualizar suas próprias informações, caso necessário.</p>
<p>Repare, ainda, em protocolos de roteamento reais baseados em Vetor de Distâncias, <strong>nós realizam o envio de seus Vetores de Distâncias para seus vizinhos periodicamente, ainda que não haja mudanças nos valores reportados</strong>. Para entender porque isso é necessário, devemos notar que a mensagem que carrega o anúncio do Vetor de Distâncias de um nó é um pacote como outro qualquer. Se a rede em questão oferece um serviço de melhor esforço — o que é o caso da Internet, por exemplo — este pacote é susceptível a corrupções e descartes. Em outras palavras, quando ocorre uma alteração no Vetor de Distâncias de um nó <span class="math inline"><em>x</em></span> e este realiza o anúncio para seus vizinhos, esta mensagem pode ser perdida. Ao invés de empregarmos algum mecanismo complexo de <em>acks</em> e retransmissões, simplesmente optamos por realizar o envio periódico dos Vetores de Distância. Esta solução têm a vantagem adicional de dar suporte direto à adição de novos nós. Como será discutido em aulas posteriores, protocolos reais também se utilizam desta periodicidade para detectarem falhas nos enlaces: se um nó deixa de receber os Vetores de Distância de um vizinho por um longo período, ele pode inferir que o enlace não está mais funcional.</p>
<h2 id="vetores-de-distância-e-mudanças-nos-custos-dos-enlaces">Vetores de Distância e Mudanças nos Custos dos Enlaces</h2>
<p>Na seção anterior, discutimos como o Algoritmo de Bellman-Ford converge sob condições razoáveis na prática. Embora isso seja verdade, protocolos de roteamento baseados em Vetor de Distâncias podem apresentar alguns comportamentos indesejados em situações em que os custos de um enlace mudam abruptamente.</p>
<p>No caso de uma <strong>redução de custo</strong>, estes protocolos conseguem lidar com a mudança de maneira satisfatória. Os nós que estabelecem o enlace em questão detectam a mudança, recalculam seus vetores de distância e, se houver alteração — <em>i.e.</em>, redução do custo de alguma rota —, o enviam para seus respectivos vizinhos. Os vizinhos, por sua vez, realizam o mesmo processo. Esta informação da melhora das condições da rede continua se propagando, até que, “rapidamente”, todos os nós da rede convergem novamente para as melhores rotas.</p>
<h3 id="contagem-ao-infinito">Contagem ao Infinito</h3>
<p>Uma situação mais problemática é <strong>o aumento abrupto do custo de um enlace</strong>. Suponha, por exemplo, que um nó <span class="math inline"><em>y</em></span> tem um enlace com um nó <span class="math inline"><em>x</em></span> com peso inicial <span class="math inline">4</span>. Suponha que a única rota alternativa de <span class="math inline"><em>y</em></span> para <span class="math inline"><em>x</em></span> é passando por um outro nó <span class="math inline"><em>z</em></span> — por um enlace de peso <span class="math inline">1</span> — que por sua vez alcança <span class="math inline"><em>x</em></span> por um enlace direto de peso <span class="math inline">50</span>. Claramente, a melhor rota para <span class="math inline"><em>y</em></span> é utilizando o enlace direto, já que <span class="math inline">4 &lt; 50 + 1</span>. Da mesma forma, embora possua um enlace direto para <span class="math inline"><em>x</em></span>, <span class="math inline"><em>z</em></span> deve utilizar a rota passando por <span class="math inline"><em>y</em></span>, já que <span class="math inline">1 + 4 &lt; 50</span>. Após algumas iterações, um protocolo baseado em vetor de distâncias facilmente convergiria para estas rotas.</p>
<p>Suponha, no entanto, que após a convergência inicial de protocolo, o enlace direto de <span class="math inline"><em>y</em></span> para <span class="math inline"><em>x</em></span> piore de forma repentina, resultando em um novo peso <span class="math inline">60</span>. Com esta mudança, as melhores rotas para <span class="math inline"><em>x</em></span> se alteram: para <span class="math inline"><em>z</em></span>, a melhor rota passa a ser o enlace direto, com custo <span class="math inline">50</span>, enquanto para <span class="math inline"><em>y</em></span> a melhor rota passa a ser através de <span class="math inline"><em>z</em></span>, com custo total <span class="math inline">51</span>.</p>
<p>Em um protocolo baseado em Vetor de Distâncias, no entanto, um nó não tem acesso ao estado completo da rede e, portanto, tem que basear suas decisões de roteamento apenas no que conhece da sua própria vizinhança. Em particular, note que quando <span class="math inline"><em>y</em></span> detecta a mudança de peso no seu enlace para <span class="math inline"><em>x</em></span>, ele possui apenas o Vetor de Distâncias de <span class="math inline"><em>z</em></span> como base para tomar uma decisão. Observe que quando <span class="math inline"><em>y</em></span> detecta esta alteração, o Vetor de Distâncias que <span class="math inline"><em>y</em></span> conhece de <span class="math inline"><em>z</em></span> lista ainda o custo antigo — <em>i.e.</em>, antes da alteração do peso do enlace — da rota que <span class="math inline"><em>z</em></span> conhecia para <span class="math inline"><em>x</em></span>. Em outras palavras, este Vetor de Distâncias ainda lista que o melhor caminho conhecido por <span class="math inline"><em>z</em></span> para alcançar <span class="math inline"><em>x</em></span> tem custo <span class="math inline">5</span>. Com base nesta informação, <span class="math inline"><em>y</em></span> realiza a seguinte decisão: devo manter minha rota para <span class="math inline"><em>x</em></span> usando o enlace direto — que agora tem custo <span class="math inline">60</span> — ou devo utilizar <span class="math inline"><em>z</em></span> como próximo salto, resultando em uma rota com custo total de <span class="math inline">1 + 5 = 6</span>? O resultado desta computação será que <span class="math inline"><em>y</em></span> optará pela rota passando por <span class="math inline"><em>z</em></span>, atualizará seu Vetor de Distâncias aumentando seu custo para <span class="math inline"><em>x</em></span> de <span class="math inline">4</span> para <span class="math inline">6</span> e o reenviará para seus vizinhos — em particular <span class="math inline"><em>z</em></span>.</p>
<p>Por sua vez, ao receber o novo Vetor de Distâncias de <span class="math inline"><em>y</em></span>, o nó <span class="math inline"><em>z</em></span> notará que a distância anunciada de <span class="math inline"><em>y</em></span> para <span class="math inline"><em>x</em></span> piorou de <span class="math inline">4</span> para <span class="math inline">6</span>. No entanto, isso não mudará a opção de <span class="math inline"><em>z</em></span> em utilizar <span class="math inline"><em>y</em></span> como próximo salto, já que <span class="math inline">6 + 1 = 7</span> ainda é menor que o custo do caminho alternativo usando o enlace direto de peso <span class="math inline">50</span>. De toda forma, o Vetor de Distâncias de <span class="math inline"><em>z</em></span> será alterado por conta no aumento do seu custo em direção a <span class="math inline"><em>x</em></span>. Isso resultará em <span class="math inline"><em>z</em></span> enviar seu novo Vetor de Distâncias para seus vizinhos — em particular, <span class="math inline"><em>y</em></span>.</p>
<p>Repare o que acontece se continuarmos este processo:</p>
<ol type="1">
<li><p><span class="math inline"><em>y</em></span> atualizará seu custo para <span class="math inline"><em>x</em></span> de <span class="math inline">6</span> para <span class="math inline">7 + 1 = 8</span>, ainda passando por <span class="math inline"><em>z</em></span> e reenviará seu Vetor de Distâncias.</p></li>
<li><p><span class="math inline"><em>z</em></span> atualizará seu custo para <span class="math inline"><em>x</em></span> de <span class="math inline">7</span> para <span class="math inline">8 + 1 = 9</span>, ainda passando por <span class="math inline"><em>y</em></span> e reenviará seu Vetor de Distâncias.</p></li>
<li><p>…</p></li>
</ol>
<p>Em resumo, <span class="math inline"><em>y</em></span> e <span class="math inline"><em>z</em></span> prosseguirão neste processo que gradativamente aumenta suas estimativas de custo em relação a <span class="math inline"><em>x</em></span> de duas em duas unidades. Repare, no entanto, que estes custos não são reais: não existe caminho nesta topologia entre <span class="math inline"><em>y</em></span> e <span class="math inline"><em>x</em></span> com custo <span class="math inline">6</span> (ou <span class="math inline">8, 10, 12, …</span>), assim como não existe caminho entre <span class="math inline"><em>z</em></span> e <span class="math inline"><em>x</em></span> com custo <span class="math inline">7</span> (ou <span class="math inline">9, 11, 13, …</span>). Note ainda que o problema não se resume a uma inconsistência no <em>custo</em> da rota, mas a própria rota escolhida não é correta: <span class="math inline"><em>y</em></span> acredita que deve encaminhar pacotes destinados a <span class="math inline"><em>x</em></span> por <span class="math inline"><em>z</em></span>, que pensa que deve encaminhar estes mesmos pacotes por <span class="math inline"><em>y</em></span>. Em outras palavras, <strong>há um <em>loop</em> no roteamento</strong>.</p>
<p>Este problema — denominado de <strong>contagem ao infinito</strong> — é apenas temporário, já que os custos destas rotas inexistentes aumentam gradativamente. Em certo momento, esta rota fictícia passa a ter custo superior ao da rota ótima, fazendo com que o roteamento convirja para uma situação normal novamente. Entretanto, isso demora algum tempo: são necessárias várias iterações e trocas de Vetores de Distância. Durante esse período, a inconsistência no roteamento pode levar a pacotes ficarem em <em>loop</em> e, eventualmente, serem descartados.</p>
<h3 id="envenenamento-reverso">Envenenamento Reverso</h3>
<p>Protocolos baseados em Vetor de Distância geralmente incluem uma contra-medida para combater a contagem ao infinito chamada de <strong>envenenamento reverso</strong> (ou <em>poisoned reverse</em>, em inglês). O mecanismo é simples. Um nó gera versões diferentes do seu Vetor de Distâncias para vizinhos diferentes. Em particular, se <span class="math inline"><em>z</em></span> utiliza <span class="math inline"><em>y</em></span> como próximo salto para o destinatário <span class="math inline"><em>x</em></span>, então no Vetor de Distâncias que <span class="math inline"><em>z</em></span> anuncia para <span class="math inline"><em>y</em></span> constará uma distância infinita em relação a <span class="math inline"><em>x</em></span>. Para seus outros vizinhos, <span class="math inline"><em>z</em></span> anuncia sua estimativa real para sua distância para <span class="math inline"><em>x</em></span>.</p>
<p>Se aplicarmos o envenenamento reverso ao exemplo anterior, é possível notar que a contagem ao infinito não ocorre. Quando o protocolo converge na situação inicial da rede — quando o enlace entre <span class="math inline"><em>y</em></span> e <span class="math inline"><em>x</em></span> tem peso <span class="math inline">4</span> — <span class="math inline"><em>z</em></span> descobre que sua melhor rota para <span class="math inline"><em>x</em></span> tem custo <span class="math inline">5</span>, utilizando <span class="math inline"><em>y</em></span> como próximo salto. Nesta situação, ao anunciar seu Vetor de Distâncias para <span class="math inline"><em>y</em></span>, <span class="math inline"><em>z</em></span> propositalmente omite sua distância conhecida para <span class="math inline"><em>x</em></span>, substituindo-a por infinito. Quando <span class="math inline"><em>y</em></span> detecta o aumento abrupto no peso do seu enlace para <span class="math inline"><em>x</em></span>, ele acredita que <span class="math inline"><em>z</em></span> não possui uma rota para <span class="math inline"><em>x</em></span> e, portanto, se vê obrigado a continuar usando a rota pelo enlace direto — agora com custo <span class="math inline">60</span>. Mesmo assim, dada a mudança no custo, <span class="math inline"><em>y</em></span> ainda atualiza seu Vetor de Distâncias e o reenvia para seus vizinhos. Ao receber este novo Vetor de Distâncias, <span class="math inline"><em>z</em></span> percebe que sua rota para <span class="math inline"><em>x</em></span> utilizando <span class="math inline"><em>y</em></span> como próximo salto teve um aumento súbito de custo — de <span class="math inline">5</span> para <span class="math inline">61</span>. Neste caso, sua rota alternativa — usando seu enlace direto para <span class="math inline"><em>x</em></span> — se torna melhor, com custo <span class="math inline">50</span>. Devido à alteração no seu Vetor de Distâncias, <span class="math inline"><em>z</em></span> o reenvia para todos os seus vizinhos. Agora, ao receber esta nova atualização de <span class="math inline"><em>z</em></span>, o nó <span class="math inline"><em>y</em></span> descobre uma rota melhor para <span class="math inline"><em>x</em></span> utilizando <span class="math inline"><em>z</em></span> como próximo salto, resultando em um custo <span class="math inline">51</span>.</p>
<p>O envenenamento reverso, portanto, é eficaz em evitar o problema de contagem a infinito <em>em várias situações</em>, <strong>embora não em todos os casos</strong>. Sabendo disso, você consegue encontrar uma situação em que o envenenamento reverso falha?</p>
<h2 id="vetor-de-distâncias-vs.-estado-de-enlaces">Vetor de Distâncias <em>vs.</em> Estado de Enlaces</h2>
<p>Uma questão natural neste ponto é: qual das duas abordagens — Vetor de Distâncias ou Estado de Enlaces — é melhor? Na realidade, não existe uma resposta absoluta. Cada abordagem apresenta vantagens em determinados aspectos, demandando que a opção por uma ou outra seja baseada nas características da rede e outros requisitos relevantes.</p>
<p>Do ponto de vista de complexidade computacional, protocolos baseados em Estado de Enlaces são, normalmente, mais custosos, tanto em termos de processamento (já que cada nó precisa computar sozinho a instância do algoritmo de caminho mínimo), quanto em termos de armazenamento (já que cada nó necessita manter uma representação completa da topologia da rede em memória). Estes fatores podem limitar a aplicabilidade deste tipo de protocolo a redes de grandes dimensões.</p>
<p>Outro fator relevante é a <strong>complexidade de troca de mensagens</strong>, ou seja, a quantidade de mensagens de controle que precisam ser trocadas entre os nós para que o protocolo consiga convergir. Neste aspecto, é preciso considerar a natureza diferente das mensagens geradas por cada tipo de protocolo: os baseados em Estado de Enlaces precisam que suas mensagens sejam difundidas por toda a rede, enquanto o escopo das mensagens usadas por protocolos baseados em Vetor de Distâncias é apenas local — <em>i.e.</em>, para os vizinhos diretos de cada nó. Por outro lado, os Vetores de Distâncias crescem com o aumento do tamanho rede, enquanto o tamanho das mensagens de controle dos protocolos baseados em Estado de Enlaces depende apenas do número de vizinhos de um nó — que, normalmente, é bem menor que o número total de nós na rede.</p>
<p>O tempo de convergência dos protocolos é outro ponto de comparação. A princípio, o tempo de convergência para um protocolo baseado em Estado de Enlaces depende do tempo de disseminação das informações de topologia, seguido do tempo de execução do Algoritmo de Dijkstra — normalmente, o tempo de comunicação é dominante neste contexto. Já nos protocolos baseados em Vetor de Distâncias, a convergência depende do número de iterações necessárias para o Algoritmo de Bellman-Ford. Por sua vez, este número de iterações depende do <strong>diâmetro da rede</strong> — <em>i.e.</em>, o maior número de saltos entre quaisquer dois nós da rede considerando as melhores rotas possíveis.</p>
<p>Ambas as abordagens estão susceptíveis a problemas como oscilações — geralmente associadas a métricas de roteamento que variam com o tráfego que passa por um enlace — e <em>loops</em>. A causa dos <em>loops</em>, no entanto, é diferente para cada tipo de protocolo: para protocolos baseados em Estado de Enlaces, <em>loops</em> decorrem de inconsistências nas visões da topologia dos vários nós; já nos baseados em Vetor de Distâncias, a causa é geralmente o problema de contagem ao infinito.</p>
<p>É possível, ainda, compará-las em termos de robustez a defeitos ou <em>bugs</em> em equipamentos. Se um roteador defeituoso anuncia custos ou pesos errados nas mensagens de controle do protocolo de roteamento, o escopo das consequências negativas tende a ser mais localizado na vizinhança deste nó em protocolos baseados em Estado de Enlace, já que um nó é responsável por anunciar pesos apenas dos seus enlaces. Por outro lado, em um protocolo baseado em Vetor de Distâncias, este escopo tende a ser bem maior, já que as informações constantes nas mensagens de controle dizem respeito ao custo de caminhos completos.</p>
<h2 id="exemplos">Exemplos</h2>
<p>Ao final dessa página, há uma pequena aplicação <code>javascript</code> que ilustra o funcionamento do roteamento baseado em Vetor de Distâncias. A aplicação permite que se altere a topologia, adicionando ou removendo nós e enlaces. Os custos dos enlaces também podem ser livremente alterados. Para os nós, é possível alterar o identificador.</p>
<p>Cada alteração realizada automaticamente dispara um recálculo do algoritmo. Os caminhos resultantes são destacados em vermelho na topologia. Além disso, a aplicação exibe um passo-a-passo da execução na tabela imediatamente abaixo da figura. Esse passo-a-passo mostra a evolução dos conteúdos dos Vetores de Distância conhecidos por cada nó — tanto os seus próprios, quanto os recebidos dos seus vizinhos.</p>
<p>Esse conjunto de vetores de distância é representado na forma de uma tabela: as linhas representam os vetores de distância de cada nó — conforme conhecido pelo nó local —, enquanto as colunas representam os destinatários. Em determinados momentos da execução, são mostradas entradas específicas no Vetor de Distâncias do nó local circuladas em vermelho: isso indica que essas entradas foram alteradas pelo nó local com base em informações recebidas nos Vetores de Distância dos seus vizinhos.</p>
<p>O passo-a-passo do algoritmo é mostrado até o instante de convergência — <em>i.e.</em>, até que as melhores rotas sejam encontradas. Além disso, note que a aplicação considera uma execução <strong>síncrona</strong> do algoritmo: <em>i.e.</em>, todos os nós enviam/recebem os vetores de distância ao mesmo tempo em um dado passo. Note, no entanto, que esse sincronismo não é necessário na prática para a convergência do algoritmo.</p>
<p>Note, ainda, que a aplicação exibe a tabela de roteamento resultante na tabela à direita da figura da topologia. A tabela exibida diz respeito ao nó selecionado atualmente na figura da topologia — <em>i.e.</em>, marcado em verde. Nós diferentes pode ser selecionados através de um clique com o botão esquerdo do <em>mouse</em>.</p>
<p>Utilize essa aplicação modificando a topologia para tentar responder as questões ou executar as experiências sugeridas abaixo:</p>
<ol type="1">
<li>Por padrão, a aplicação carrega uma simples topologia composta por três nós. Observe o passo-a-passo para essa topologia e responda: quanto tempo — <em>i.e.</em>, passos de troca de Vetores de Distância — são necessários até a convergência?</li>
<li>Agora altere ligeiramente a topologia padrão, adicionando um novo nó conectado apenas ao nó <code>Z</code>. O que ocorre com o tempo de convergência?</li>
<li>Altere a topologia usada no item anterior, criando um enlace entre o novo nó e o nó <code>Y</code>. Configure um peso para esse enlace que seja menor ou igual ao peso do enlace entre o novo nó e <code>Z</code>. O tempo de convergência foi aumentado ou reduzido?</li>
<li>Agora altere o peso do enlace entre o novo nó e <code>Y</code>, aumentando-o para um valor mais alto que a soma dos pesos dos enlaces do novo nó para <code>Z</code> e de <code>Z</code> para <code>Y</code>. O tempo de convergência foi alterado? Você consegue ver a relação entre o tempo de convergência e alguma característica da topologia?</li>
<li>Essa implementação utiliza envenenamento reverso? Utilize um exemplo para demonstrar que sim ou que não.</li>
</ol>
<iframe src="DV.html" onload="this.style.height=(this.contentWindow.document.body.scrollHeight+40)+ 'px';" style="width: 100%;"/>
</body>
</html>
