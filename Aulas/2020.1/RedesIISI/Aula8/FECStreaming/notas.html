<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Métodos de FEC para Streaming Multimídia</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Métodos de FEC para Streaming Multimídia</h1>
</header>
<p>Embora boa parte das aplicações multimídia sejam tolerantes a perdas, perdas de pacotes afetam negativamente a experiência do usuário. Em outras palavras, embora a aplicação possa funcionar <em>bem o suficiente</em> para cumprir o seu propósito básico, essas perdas de pacotes reduzem a qualidade da mídia reproduzida no lado receptor. Além disso, mesmo tolerando <em>algum</em> nível de perda de pacotes, há um determinado ponto em que as perdas se tornam excessivas e a aplicação passa a não cumprir nem mesmo seu propósito básico, do ponto de vista do usuário. Dessa forma, mitigar a ocorrência e os efeitos das perdas de pacotes pode ser do interesse desse tipo de aplicação.</p>
<p>Ao longo do nosso estudo sobre redes de computadores, vimos duas abordagens gerais para a recuperação de pacotes/informações perdidas/corrompidas:</p>
<ol type="1">
<li>retransmissões associadas com pacotes de confirmação (<em>acks</em>);</li>
<li>métodos de FEC (<em>Forward Error Correction</em>), <em>i.e.</em>, métodos de correção de pacotes com base em bits/informações redundantes.</li>
</ol>
<h2 id="retransmissões">Retransmissões</h2>
<p>Embora as retransmissões sejam um método efetivo de recuperação de pacotes em diversos protocolos práticos — notavelmente, no TCP —, as restrições temporais das aplicações multimídia podem tornar esse mecanismo inviável. Considere, por exemplo, uma ligação VoIP entre dois usuários localizados em continentes diferentes — digamos, um no Rio de Janeiro e outro em Canberra, na Austrália. Ainda que utilizássemos um enlace direto entre esses dois usuários passando por uma geodésica<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, o comprimento desse enlace seria de aproximadamente 13500 quilômetros, o que resultaria em um atraso de propagação de aproximadamente <span class="math inline">\(\frac{13500}{200\times 10^6} = 67,5\)</span> ms. Isso significa que, mesmo nesse cenário idealizado, o RTT dessa comunicação seria de, no mínimo, <span class="math inline">\(2\times 67,5 = 135\)</span> ms.</p>
<p>Note que, na prática, esses dois usuários provavelmente não estarão conectados através de um enlace direto, mas sim através de uma rota composta por vários enlaces. O trajeto físico desses enlaces também muito provavelmente não seguirá uma geodésica — talvez nem mesmo algo próximo disso —, podendo envolver, inclusive, enlaces de satélite ou caminhos passando por outros continentes. Todos esses fatores fazem com que o tempo total de propagação seja substancialmente maior. Além disso, esses enlaces provavelmente seriam compartilhados com outros fluxos, o que adicionaria atrasos de enfileiramento. Por fim, estamos ainda ignorando outros tempos, como atrasos de transmissão em cada enlace, atrasos de aquisição do áudio e atrasos de processamento ao longo de todo o caminho. Em suma: é provável que esse RTT se aproxime ou ultrapasse os 250 ms.</p>
<p>Lembre-se que aplicações de conversação geralmente têm uma tolerância de algumas centenas de milissegundos entre o momento em que um dos lados fala alguma coisa até o momento em que essa fala é reproduzida do outro lado. Note como essa nossa estimativa de RTT no cenário de exemplo já se aproxima desse limite máximo. Assim, se um transmissor tiver que esperar por um <em>ack</em> — ou pela sua ausência — para perceber a perda do pacote e, então, disparar a retransmissão, essa retransmissão aconteceria ao menos<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 250 ms depois da tentativa original. Ainda que essa segunda tentativa de transmissão chegue com sucesso ao destinatário, é possível que o pacote chegue tarde demais para ser reproduzido.</p>
<p>Por todos esses motivos, retransmissões são raramente utilizadas nesse tipo de aplicação. Uma possível exceção seriam aplicações especializadas em que se tem certeza de que os participantes da chamada estão “próximos o suficiente” para que os requisitos temporais não impeçam o uso de retransmissões.</p>
<h2 id="fec">FEC</h2>
<p>O mais comum, no entanto, é que retransmissões sejam consideradas inviáveis. Assim, os métodos de FEC surgem como alternativas potencialmente interessantes. Lembre-se que um método de FEC inclui bits redundantes na transmissão que permite ao receptor conseguir recuperar informações perdidas ou corrompidas de alguma forma. Esses métodos, por tanto, adicionam um pouco de <em>overhead</em> à comunicação em troca da possibilidade de recuperar dados perdidos sem retransmissões.</p>
<p>Quando estudamos protocolos da Camada de Enlace, vimos que esses mecanismos de FEC são frequentemente utilizados. Métodos como a Paridade Bidimensional e o Código de Hamming quebram os bits de um quadro em blocos de determinado tamanho e adicionam bits de redundância a cada um desses blocos. Ao final, os blocos aumentados com os bits de redundância são transmitidos na forma de um pacote pelo enlace.</p>
<p>Essa abordagem, entretanto, não ajuda a mitigar as perdas de pacotes das aplicações multimídia, porque, na maioria das vezes, os pacotes não chegam corrompidos: eles simplesmente não são entregues ao <em>host</em> destino. Assim, introduzir bits redundantes no próprio pacote não é uma solução para o problema.</p>
<p>Ao invés disso, os métodos de FEC utilizados por essas aplicações <strong>introduzem bits redundantes relativos a um pacote em outro pacote do fluxo</strong>. Esse outro pacote pode ser um pacote adicional com o único propósito de prover redundância ou pode ser um outro pacote que carrega parte da mídia no qual anexamos bits redundantes referentes a uma parte anterior. Nas próximas seções, veremos alguns exemplos de abordagens possíveis.</p>
<h3 id="exemplo-de-fec-com-pacote-redundante">Exemplo de FEC com Pacote Redundante</h3>
<p>Nesse método de FEC, dividimos a sequência de pacotes do fluxo multimídia em grupos de <span class="math inline">\(n\)</span> pacotes consecutivos — <span class="math inline">\(n\)</span> é um parâmetro do método. Para cada grupo, criamos um pacote <span class="math inline">\(n+1\)</span> cujo conteúdo corresponde ao resultado da operação de <em>ou-exclusivo</em> bit-a-bit dos <span class="math inline">\(n\)</span> outros pacotes. Em outras palavras:</p>
<p><span class="math display">\[P_{n+1} = P_1 \oplus P_2 \dots \oplus P_n.\]</span></p>
<p>Para ilustrar a utilidade disso, suponha que, para um determinado fluxo, <span class="math inline">\(n = 4\)</span> e o receptor deixa de receber o terceiro pacote de um determinado grupo. No entanto, todos os demais pacotes desse grupo foram recebidos com sucesso, incluindo o pacote redundante <span class="math inline">\(P_{n+1}\)</span>. Como podemos usar esse pacote redundante para recuperar <span class="math inline">\(P_3\)</span>?</p>
<p>Isso pode ser feito observando que a operação de <em>ou-exclusivo</em> bit-a-bit é análoga a uma soma — ou subtração — módulo 2. Com base nisso, podemos reescrever a equação acima na seguinte forma:</p>
<p><span class="math display">\[P_3 = P_1 \oplus P_2 \oplus P_4 \oplus P_{n+1}.\]</span></p>
<p>Em outras palavras e de forma mais geral, de posse de quaisquer <span class="math inline">\(n\)</span> pacotes de um grupo, podemos calcular o pacote faltante simplesmente fazendo a operação de <em>ou-exclusivo</em> bit-a-bit entre os pacotes que possuímos. Se mais de um pacote no grupo é perdido, então o método é incapaz de recuperar as perdas.</p>
<p>A escolha do valor do parâmetro <span class="math inline">\(n\)</span> manipula um compromisso entre aumento do <em>overhead</em> adicionado pelo pacote redundante e o aumento da probabilidade de recuperação. No limite, se usarmos <span class="math inline">\(n=1\)</span>, então cada pacote do fluxo multimídia será seguido de um pacote redundante — nesse caso, uma cópia exatamente do único pacote do grupo. Isso representa um <em>overhead</em> de 100%, mas consegue recuperar qualquer perda que aconteça nos pacotes do fluxo, desde que o pacote redundante correspondente seja recebido. Por outro lado, ao aumentarmos o valor de <span class="math inline">\(n\)</span>, reduzimos o <em>overhead</em> ao custo de tornar menos provável a recuperação de um pacote do fluxo, porque é possível que outro pacote do grupo seja perdido também.</p>
<p>Além disso, repare que se o primeiro pacote de um grupo é perdido, ainda que seja possível recuperá-lo, teremos que aguardar todos os demais pacotes do grupo — incluindo o redundante. Isso significa que a própria recuperação demora algum tempo e que esse tempo cresce à medida que aumentamos o parâmetro <span class="math inline">\(n\)</span>. Dadas as restrições temporais associadas a esse tipo de aplicação, valores altos de <span class="math inline">\(n\)</span> se tornam inviáveis.</p>
<h3 id="exemplo-de-fec-sem-pacote-redundante">Exemplo de FEC sem Pacote Redundante</h3>
<p>Um outro método alternativo de FEC é o envio de <strong>versões de menor qualidade</strong> do conteúdo de um pacote <strong>anexadas em pacotes posteriores</strong> — operação muitas vezes chamada de <em>piggybacking</em>. A ideia se baseia na observação de que fluxos multimídia — <em>e.g.</em>, áudio e vídeo — geralmente podem ser codificados em diferentes níveis de qualidade, resultando em representações de diferentes tamanhos. Mais especificamente, em geral, quanto maior a qualidade da codificação de uma mídia, maior o tamanho resultante.</p>
<p>Podemos explorar essa característica criando duas codificações de qualidades diferentes de cada trecho da mídia transmitida. Cada pacote do fluxo transportará dois trechos diferentes da mídia: o trecho atual codificado na maior qualidade e o trecho imediatamente anterior codificado na qualidade mais baixa. Caso o receptor não receba um pacote, ele ainda pode obter o trecho correspondente no pacote subsequente do fluxo. Embora esse trecho estará em uma versão de menor qualidade, reproduzi-lo é melhor que não reproduzir nada do ponto de vista da experiência do usuário.</p>
<p>Assim como qualquer método de FEC, este método introduz algum nível de <em>overhead</em> na comunicação ao incluir informações redundantes no fluxo de pacotes. Entretanto, com a utilização de uma codificação de menor qualidade para os trechos redundantes, conseguimos reduzir esse <em>overhead</em>. Em particular, essa relação entre as qualidades original e redundante pode ser manipulada de forma a se obter um determinado <em>overhead</em> máximo desejado.</p>
<p>Note também que o método descrito nos parágrafos anteriores falha no caso de dois ou mais pacotes consecutivos serem perdidos: nesse caso, apenas o último pacote da sequência perdida será recuperado quando pacote subsequente for recebido. É possível, entretanto, estender a ideia desse método para aumentar sua abrangência de recuperação. Para isso, podemos criar três ou mais versões da mídia, cada uma com uma qualidade diferente. Assim, cada pacote carregaria vários trechos: o atual, na melhor qualidade, o imediatamente anterior, em uma qualidade mais baixa, o anterior, em uma qualidade ainda mais baixa, e assim por diante. Em um esquema desse tipo com <span class="math inline">\(n\)</span> trechos por pacote, conseguiríamos recuperar até <span class="math inline">\(n-1\)</span> perdas de pacotes consecutivas, ao custo de um aumento no <em>overhead</em>.</p>
<p>Por outro lado, deve-se notar também que as mesmas restrições relacionadas ao tempo de recuperação citadas na seção anterior se aplicam aqui: não adianta crescer esse número <span class="math inline">\(n\)</span> de trechos carregados em cada pacote arbitrariamente porque, em certo ponto, se torna tarde demais para recuperarmos um pacote perdido, considerando o seu prazo de reprodução.</p>
<h3 id="interleaving">Interleaving</h3>
<p>Encerraremos esse material discutindo uma terceira abordagem para mitigação de perdas de pacotes em fluxos multimídia. A rigor, essa abordagem — denominada <em>interleaving</em> — <strong>não é um método de FEC</strong>, porque ela não é capaz de recuperar o conteúdo dos pacotes perdidos, nem mesmo em uma versão de mais baixa qualidade. Ao invés disso, o que o <em>interleaving</em> alcança é um mascaramento desses episódios de perda.</p>
<p>A ideia do <em>interleaving</em> é “dissolver” os efeitos da perda de um pacote, espalhando-os por um período mais longo. Para isso, o transmissor quebra os trechos transportados em cada pacote em pedaços menores. Por exemplo, digamos que cada pacote carregue trechos de 20 ms de áudio. Podemos subdividir cada um desses trechos em unidades menores de 5 ms. Ou seja, cada pacote carregará 4 unidades. Mas ao invés de cada pacote transportar cinco unidades consecutivas, essas unidades são espalhadas por vários pacotes diferentes, como exemplificado na figura abaixo:</p>
<figure>
<img src="imagens/Interleaving.svg" style="max-width: 800px; width: 100%;" alt="" /><figcaption>(Adaptado dos slides do livro texto “Redes de computadores e a internet: uma abordagem top-down”)</figcaption>
</figure>
<p>A figura mostra quatro trechos de 20 ms de um fluxo de áudio, cada um dos quais subdivididos em 4 unidades menores de 5 ms cada. Ao invés de encapsular cada trecho de 20 ms consecutivos em um pacote, essas unidades menores são embaralhadas — deterministicamente —. Mais especificamente, a primeira unidade de cada trecho é colocada no primeiro pacote; a segunda unidade de cada trecho é colocada no segundo pacote; a terceira unidade de cada trecho é colocada no terceiro pacote; e a quarta unidade de cada trecho é colocada no quarto pacote. Esses pacotes são transmitidos pela rede e, nesse exemplo hipotético, o terceiro pacote é perdido. Os pacotes que são efetivamente recebidos tem seus conteúdos reorganizados pelo receptor, que monta, da melhor forma possível o fluxo original.</p>
<p>Essa remontagem não é perfeita por conta da perda do terceiro pacote, mas note que essa perda é “espalhada” pelos quatro trechos de 20 ms. Assim, o áudio reproduzido terá alguns instantes de falha, mas serão pequenos subtrechos não consecutivos de 5 ms. Em geral, isso produz um áudio com uma qualidade superior, em relação à alternativa de um trecho completo de 20 ms faltando.</p>
<p>Assim como em todos os outros métodos, o <em>interleaving</em> traz alguns compromissos. Repare, por exemplo, que no cenário ilustrado na figura acima o transmissor teve que capturar 4 trechos de 20 ms de áudio — 80 ms no total — antes de poder transmitir o primeiro pacote, porque cada pacote carrega unidades de cada um desses 4 trechos. Esse tempo de espera para que o último trecho necessário seja capturado é mais um atraso que compõe o tempo total entre a aquisição do áudio e sua reprodução no receptor. Assim como para os demais métodos, a utilização ou não do <em>interleaving</em> e sua parametrização adequada (<em>i.e.</em>, número de trechos e subtrechos em cada pacote) dependem de uma correta avaliação de se esse atraso total de reprodução ainda será baixo o suficiente para garantir uma boa interação entre os interlocutores.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Nesse contexto, uma geodésica é a curva de menor comprimento entre dois pontos, considerando a curvatura da Terra.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Repare que, na prática, o transmissor provavelmente aguardaria mais que os 250 ms de RTT, por causa do <em>jitter</em> da rede. Do contrário, estaríamos arriscando realizar uma série de retransmissões desnecessárias causadas por uma demora um pouco maior para a recepção do <em>ack</em>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
