<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Impacto das Redes Sem Fio nas Camadas Superiores</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Impacto das Redes Sem Fio nas Camadas Superiores</h1>
</header>
<p>O estudo e o desenvolvimento das redes de computadores geralmente é organizado através de modelos em camadas, como o modelo TCP/IP e o modelo ISO/OSI. Nesses modelos, cada camada é entendida como um módulo com responsabilidades específicas e interfaces bem definidas para outros módulos — especificamente, aqueles correspondentes às camadas imediatamente acima e abaixo na pilha. Teoricamente, essa modularização “esconde” de uma camada a implementação das demais. Assim, seria possível substituir a implementação de uma determinada camada por outra que mantivesse as mesmas interfaces e todo o sistema deveria funcionar normalmente.</p>
<p>De fato, essa modularização provida pelos modelos em camada é relativamente bem sucedida nesse objetivo. Por exemplo, na Internet há dois protocolos clássicos de camada de transporte: UDP e TCP. À principio, uma aplicação pode utilizar a implementação mais adequada a seus propósitos e, na prática, existem diversos exemplos de aplicações que usam cada uma delas. Outros exemplos incluem o IPv4 e o IPv6 que coexistem na Internet pública, além das várias tecnologias de camada de enlace.</p>
<p>Entretanto, o fato das redes <strong>funcionarem</strong> com a substituição da implementação de determinadas camadas não implica a inexistência de <strong>impactos perceptíveis</strong> nessa troca. Nessas notas de aula, discutiremos brevemente alguns dos potenciais impactos do uso de enlaces sem fio nas camadas superiores da pilha de protocolos TCP/IP.</p>
<h2 id="desempenho">Desempenho</h2>
<p>Os impactos mais óbvios do uso dos enlaces sem fio estão no desempenho obtido. Embora os padrões de comunicação sem fio tenham evoluído bastante nos últimos anos em termos de taxas de transmissão, em geral, tecnologias cabeadas correspondentes ainda preveem taxa mais altas. Por exemplo, enquanto a emenda IEEE 802.11ac, aprovada em 2013, prevê taxas de até 6,77 Gb/s — ainda assim, sob condições bastante especiais —, o IEEE 802.3 especifica desde 2003 Ethernet de 10 Gb/s sobre fibra ótica e desde 2004 sobre cabos de cobre.</p>
<p>Note, no entanto, que a taxa de transmissão de um enlace é só um dos aspectos relevantes de desempenho. Em particular, quando falamos do IEEE 802.11, devemos lembrar que se trata de um padrão que suporta múltiplas taxa. Ou seja, quando citamos que o IEEE 802.11ac suporta taxas de até 6,77 Gb/s, estamos nos referindo à taxa máxima suportada que demanda uma relação sinal-ruído consideravelmente alta para se tornar viável.</p>
<p>Além disso, quadros transmitidos no meio sem fio são, em geral, bem mais susceptíveis a falhas que aqueles transmitidos por meios cabeados. Isso faz com que a vazão obtida em um enlace sem fio — e, portanto, em um caminho que o contém — seja, na prática, mais baixa do que a <strong>taxa de transmissão nominal</strong>.</p>
<p>Outro fator que contribui para isso são os <em>overheads</em> de acesso ao meio. O IEEE 802.11, por exemplo, utiliza o CSMA/CA que introduz diversas fontes de <em>overhead</em> dessa natureza: intervalos como o SIFS e o DIFS, o tempo necessário para a transmissão do <em>ack</em>, <em>backoffs</em> aleatórios após episódios de colisão. Embora os quadros de dados sejam transmitidos a uma determinada taxa nominal, todos esses <em>overheads</em> reduzem ainda mais a vazão obtida.</p>
<h2 id="mobilidade">Mobilidade</h2>
<p>A possibilidade de mobilidade, muitas vezes associadas ao uso de tecnologias de comunicação sem fio é outro fator que pode se manifestar nas camadas mais altas. Embora tenhamos estudado uma série de soluções para viabilizar as operações de mobilidade, nem sempre as implementações práticas as seguem. Em redes IEEE 802.11 reais, é comum que a mobilidade interfira na experiência do usuário. Por exemplo, o processo de <em>handoff</em> de um ponto de acesso para outro pode demorar mais que o esperado — por exemplo, determinados quadros trocados entre a estação cliente e o ponto de acesso de destino podem ser perdidos —, resultando em períodos significativos de desconexão da estação. Durante esse período, se o usuário estava ativamente acessando a rede, é possível que conexões sejam quebradas.</p>
<h2 id="tcp-e-enlaces-sem-fio">TCP e Enlaces Sem Fio</h2>
<p>Talvez o exemplo mais eloquente de impactos do uso de enlaces sem fio nas camadas superiores seja o do controle de congestionamento do TCP. Os algoritmos tradicionais de controle de congestionamento do TCP, como o TCP Tahoe e o TCP Reno, inferem a ocorrência de congestionamentos através das perdas de pacotes e, como consequência, reduzem a taxa de transmissão atual. De fato, o descarte de pacotes por <em>buffer overflow</em> é uma das consequências do congestionamento em redes, justificando essa abordagem.</p>
<p>Entretanto, em enlaces sem fio é comum que pacotes sejam perdidos devido a falhas na transmissão pelo meio físico — seja por colisões, por interferências temporárias ou por uma baixa relação sinal-ruído. Dessa forma, é possível que um segmento TCP seja perdido em um enlace sem fio ainda que a conexão esteja utilizando uma taxa de transmissão bem abaixo da capacidade da rede/caminho. Mesmo assim, o TCP não tem conhecimento sobre as causas da perda, apenas sobre a sua ocorrência. Nesse caso, o controle de congestionamento do TCP erroneamente interpreta a perda por uma falha no enlace como um sinal de congestionamento e reduz a taxa de transmissão antecipando uma situação de congestionamento.</p>
<p>Dessa forma, caminhos que contêm enlaces sem fio — principalmente aqueles baseados em contenção — constituem alguns dos cenários mais desafiadores para o controle de congestionamento do TCP<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Isso é um problema conhecido há muitos anos e, por isso, existem propostas para tentar superá-lo. De forma geral, essas propostas podem ser divididas em três abordagens: utilizar métodos de recuperação local de perdas, utilizar algoritmos de controle de congestionamento cientes dos enlaces sem fio e utilizar conexões divididas.</p>
<p>Das três, a abordagem mais simples é a da recuperação local de perdas. A ideia é basicamente incluir mecanismos de detecção e recuperação da perda de quadros nas próprias tecnologias de camada de enlace para os enlaces de comunicação sem fio. Isso é feito, por exemplo, pelo IEEE 802.11, que inclui na sua implementação do CSMA/CA o uso de <em>acks</em>, temporizadores e retransmissões para a recuperação local dos quadros perdidos. Isso permite uma recuperação mais rápida dos episódios de perda, que são “mascarados” do ponto de vista do TCP. Mesmo assim, o número de vezes que o IEEE 802.11 tenta retransmitir um quadro é limitado — por padrão, 4 vezes para quadros grandes —, fazendo com que algumas perdas definitivas — do ponto de vista da camada de enlace — ocorram. Assim, esse mecanismo tem a capacidade de mitigar os efeitos, mas não de eliminar completamente os problemas associados às perdas de quadros e ao funcionamento do controle de congestionamento.</p>
<p>Existem também propostas de algoritmos de controle de congestionamento alternativos para o TCP que visam lidar melhor com esse tipo de perda de pacote. Uma abordagem particularmente popular é trocar a informação utilizada para inferir congestionamento: ao invés de olhar especificamente para os episódios de perda, as decisões de controle de congestionamento são tomadas sobre medidas de atraso ou de vazão. O atraso é um outro indicador forte de episódios de congestionamento, porque ele tende a subir notavelmente quando os níveis de enfileiramento nos roteadores intermediários começam a aumentar. Sob certos pontos de vista, o atraso é até um indicador melhor de congestionamento que as perdas de pacotes, porque ele ocorre antes: o descarte de pacotes só ocorre quando a situação de congestionamento perdura por bastante tempo e o enfileiramento alcança níveis extremos. Um exemplo de algoritmo famoso de controle de congestionamento do TCP baseado em atraso é o TCP Westwood, que conta com implementações disponíveis para alguns sistemas operacionais modernos<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>Note, entretanto, que o uso do atraso como indicador de congestionamento também está passivo de problemas. Considere, por exemplo, o CSMA/CA no IEEE 802.11: quando uma tentativa de transmissão de um quadro falha por qualquer motivo, o transmissor entra em <em>backoff</em>, o que pode adicionar um atraso representativo na transmissão e sinalizar erroneamente uma situação de congestionamento para vertentes do controle de congestionamento do TCP baseadas em atraso. Além disso, o atraso também pode variar de maneira considerável quando há trocas de rotas na Internet — por exemplo, para um caminho passando por mais enlaces. Isso também precisa ser levado em conta no controle de congestionamento.</p>
<p>A última família de abordagens consiste na ideia de dividir a conexão fim-a-fim em duas partes: uma para o segmento cabeado e outra para o segmento sem fio. Nesse contexto, <em>segmento</em> denota a porção do caminho que contém cada tipo de enlace. Por exemplo, para um <em>laptop</em> associado a um ponto de acesso Wi-Fi que estabelece uma conexão TCP com um servidor qualquer na Internet, um segmento pode ser definido como o sub-caminho do <em>laptop</em> ao ponto de acesso, enquanto o segundo pode ser do ponto de acesso até o servidor. Nesse cenário, haveria basicamente duas conexões TCP: do <em>laptop</em> para o ponto de acesso e do ponto de acesso para o servidor. O ponto de acesso faria uma ponte entre as duas conexões, repassando dados recebidos por uma para a outra. Cientes de que se trata de um enlace sem fio, <em>laptop</em> e ponto de acesso podem usar um algoritmo de controle de congestionamento específico, que lide melhor com as perdas de pacote no enlace. Vários pesquisadores já reportaram experiências bem sucedidas utilizando soluções desse tipo, embora elas ainda não sejam amplamente adotadas na prática.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Outro cenário problemático para o controle de congestionamento do TCP são redes com alta capacidade e alto RTT. Essas redes demandam o uso de janelas de congestionamento muito grandes para que se alcance uma taxa de transmissão próxima à capacidade da rede, fazendo com que o TCP muitas vezes apresente desempenho abaixo do esperado.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Já há vários anos, uma implementação do TCP Westwood foi incorporada no <em>kernel</em> oficial do Linux. Embora essa variante não seja a usada por padrão, ela pode ser selecionada através de configurações do sistema.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
